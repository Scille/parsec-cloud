// Parsec Cloud (https://parsec.cloud) Copyright (c) BUSL-1.1 2016-present Scille SAS

use super::schannel_utils;
use libparsec_types::X509WindowsCngURI;
use schannel::{cert_context::CertContext, cert_store::CertStore};
use std::os::raw::c_void;
use windows_sys::Win32::Security::Cryptography;

/// Possible filter to use
/// A detailed list can be found here:
/// https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-certfindcertificateinstore
// NOTE: We do not include a SHA256 filter
// `windows-sys` does not provide the constant `CERT_FIND_SHA256_HASH` to remain compatible with
// older windows version.
// We do not use SHA1 because it's in the process to be deprecated:
// - https://learn.microsoft.com/en-us/lifecycle/announcements/sha-1-signed-content-retired
// - https://github.com/rustls/rustls-cng/blob/5070ce12b5cec229316b5f8059f71881c2deddcd/src/store.rs#L154-L159
pub(super) enum CertFilter<'a> {
    #[expect(
        dead_code,
        reason = "Will be used once we impl a custom dialog to show detected certificate"
    )]
    Any,
    /// Search for certificate with an associated private key.
    #[expect(
        dead_code,
        reason = "Will be used once we impl a custom dialog to pre-filter cert"
    )]
    HasPrivateKey,
    // Filter certificate having the given `CERT_ID`
    CertID {
        id: Cryptography::CERT_ID,
        _marker: std::marker::PhantomData<&'a ()>,
    },
}

impl<'a> CertFilter<'a> {
    fn to_params(&self) -> (u32, Cryptography::CERT_FIND_FLAGS, *const c_void) {
        match self {
            Self::Any => (0, Cryptography::CERT_FIND_ANY, std::ptr::null()),
            Self::HasPrivateKey => (0, Cryptography::CERT_FIND_HAS_PRIVATE_KEY, std::ptr::null()),
            Self::CertID { id, .. } => (
                0,
                Cryptography::CERT_FIND_CERT_ID,
                id as *const _ as *const _,
            ),
        }
    }
}

impl<'a> CertFilter<'a> {
    pub fn cert_id(uri: &'a mut X509WindowsCngURI) -> Self {
        let issuer = Cryptography::CRYPT_INTEGER_BLOB {
            cbData: uri.issuer.len() as u32,
            pbData: uri.issuer.as_mut_ptr(),
        };
        let serial_number = Cryptography::CRYPT_INTEGER_BLOB {
            cbData: uri.serial_number.len() as u32,
            pbData: uri.serial_number.as_mut_ptr(),
        };
        let cert_id = Cryptography::CERT_ID {
            dwIdChoice: Cryptography::CERT_ID_ISSUER_SERIAL_NUMBER,
            Anonymous: Cryptography::CERT_ID_0 {
                IssuerSerialNumber: Cryptography::CERT_ISSUER_SERIAL_NUMBER {
                    Issuer: issuer,
                    SerialNumber: serial_number,
                },
            },
        };
        Self::CertID {
            id: cert_id,
            _marker: Default::default(),
        }
    }
}

pub(super) fn find_cert_in_store<'a>(
    store: &'a CertStore,
    filter: CertFilter<'a>,
) -> CertInStore<'a> {
    CertInStore {
        store,
        filter,
        cur: None,
    }
}

pub(super) struct CertInStore<'a> {
    store: &'a CertStore,
    filter: CertFilter<'a>,
    cur: Option<CertContext>,
}

impl<'a> Iterator for CertInStore<'a> {
    type Item = CertContext;

    fn next(&mut self) -> Option<Self::Item> {
        let raw_store = schannel_utils::get_raw_store(self.store);

        // SAFETY:
        //
        // - The store pointer come from the iterator context.
        // - We need to pass a raw cert context pointer to `CertFindCertificateInStore`, that
        // pointer come from the previous value generated by the function.
        // - The `find_*` params are generated with the correct value by following the
        // documentation.
        unsafe {
            let cur = self.cur.take().map(|p| {
                let ptr = schannel_utils::cert_context_to_raw(&p);
                // Need to forget the wrapper as the windows function while free the inner pointer.
                std::mem::forget(p);
                ptr
            });
            // Use null value on first iteration.
            let cur = cur.unwrap_or(std::ptr::null_mut());
            let (find_flags, find_type, find_param) = self.filter.to_params();
            let next = Cryptography::CertFindCertificateInStore(
                raw_store,
                Cryptography::X509_ASN_ENCODING,
                find_flags,
                find_type,
                find_param,
                cur,
            );

            if next.is_null() {
                self.cur = None;
                None
            } else {
                let next = schannel_utils::cert_context_from_raw(next);
                self.cur = Some(next.clone());
                Some(next)
            }
        }
    }
}
