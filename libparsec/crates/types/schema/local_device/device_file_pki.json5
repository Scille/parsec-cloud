{
    "label": "DeviceFilePKI",
    "type": "pki",
    // Introduced in Parsec 3.8.0
    "introduced_in_revision": 380,
    "other_fields": [
        {
            // This refers to when the device file has been originally created.
            "name": "created_on",
            "type": "DateTime"
        },
        {
            // This field gets updated every time the device file changes its protection.
            "name": "protected_on",
            "type": "DateTime"
        },
        {
            // Url to the server in the format `https://parsec.example.com:443`.
            // Note we don't use the `parsec3://` scheme here to avoid compatibility
            // issue if we later decide to change the scheme.
            "name": "server_url",
            "type": "ParsecAddr"
        },
        {
            "name": "organization_id",
            "type": "OrganizationID"
        },
        {
            "name": "user_id",
            "type": "UserID"
        },
        {
            "name": "device_id",
            "type": "DeviceID"
        },
        {
            "name": "human_handle",
            "type": "HumanHandle"
        },
        {
            "name": "device_label",
            "type": "DeviceLabel"
        },
        {
            // Certificate here refers to the X509 certificate that describes what is
            // in the smartcard.
            "name": "certificate_ref",
            "type": "X509CertificateReference"
        },
        {
            // Used to encrypt the secret key
            "name": "algorithm",
            "type": "PKIEncryptionAlgorithm"
        },
        {
            // `SecretKey` encrypted by asymmetric key from the smartcard.
            "name": "encrypted_key",
            "type": "Bytes"
        },
        {
            // `LocalDevice` encrypted with the secret key from the `encrypted_key` field.
            "name": "ciphertext",
            "type": "Bytes"
        },
        {
            // When TOTP is not used, `ciphertext` contains data encrypted by the
            // key obtained from the primary protection (i.e. the cooking of the
            // user-provided password).
            //
            // When TOTP is used, `ciphertext` is contains data encrypted:
            // - First using the secret key obtained from the primary protection.
            // - Then using the secret key obtained from the TOTP challenge.
            // Put it another way, the local device decryption is done this way:
            //
            // ```rust
            // let key_from_primary_protection: SecretKey = ...
            // let key_from_totp_challenge: SecretKey = do_totp_challenge(
            //     <totp_opaque_key_id>,
            //     <one_time_password>
            // ).await;
            // let cleartext = key_from_totp_challenge.decrypt(
            //     key_from_primary_protection.decrypt(ciphertext)
            // );
            // let device = LocalDevice::load(cleartext);
            // ```
            "name": "totp_opaque_key_id",
            "type": "RequiredOption<TOTPOpaqueKeyID>"
        }
    ]
}
