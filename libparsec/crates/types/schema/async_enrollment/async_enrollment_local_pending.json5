{
    "label": "AsyncEnrollmentLocalPending",
    "type": "async_enrollment_local_pending",
    "other_fields": [
        {
            // Url to the server in the format `https://parsec.example.com:443`.
            // Note we don't use the `parsec3://` scheme here to avoid compatibility
            // issue if we later decide to change the scheme.
            "name": "server_url",
            "type": "ParsecAddr"
        },
        {
            "name": "organization_id",
            "type": "OrganizationID"
        },
        {
            "name": "submitted_on",
            "type": "DateTime"
        },
        {
            "name": "enrollment_id",
            "type": "AsyncEnrollmentID"
        },
        {
            // Submitter asks for device_label/human_handle, but accepter has final word on this
            "name": "requested_device_label",
            "type": "DeviceLabel"
        },
        {
            "name": "requested_human_handle",
            "type": "HumanHandle"
        },
        {
            // The identity system refers to the 3rd party component that is responsible for:
            // 1 - Sign the submit payload
            // 2 - Protect the soon-to-become user&device private keys
            // 3 - Validate the accept payload
            "name": "identity_system",
            "type": "AsyncEnrollmentLocalPendingIdentitySystem"
        },
        {
            // To-be-created device's `VerifyKey` encrypted with the ciphertext
            // key (i.e. a `SecretKey`) from the identity system.
            "name": "ciphertext_signing_key",
            "type": "Bytes"
        },
        {
            // To-be-created user's `PrivateKey` encrypted with the ciphertext
            // key (i.e. a `SecretKey`) from the identity system.
            "name": "ciphertext_private_key",
            "type": "Bytes"
        }
    ],

    "nested_types": [
        {
            "name": "AsyncEnrollmentLocalPendingIdentitySystem",
            "discriminant_field": "type",
            "variants": [
                {
                    "name": "PKI",
                    "discriminant_value": "PKI",
                    "fields": [
                        {
                            // The ciphertext key (i.e. a `SecretKey`) encrypted
                            // by an asymmetric key from the smartcard.
                            "name": "encrypted_key",
                            "type": "Bytes"
                        },
                        {
                            // Reference to the asymmetric key from the smartcard used
                            // to encrypt the ciphertext key.
                            "name": "certificate_ref",
                            "type": "X509CertificateReference"
                        },
                        {
                            // Algorithm used to encrypt `encrypted_key` field
                            "name": "algorithm_for_encrypted_key",
                            "type": "PKIEncryptionAlgorithm"
                        }
                    ]
                },
                {
                    "name": "OpenBao",
                    "discriminant_value": "OPEN_BAO",
                    "fields": [
                        // A word about the OpenBao info stored here.
                        //
                        // To fetch/upload an OpenBao secret we need multiple things:
                        // 1. The address of the OpenBao server.
                        // 2. The authentication to use (e.g. "OIDC SSO with Github as identity provider").
                        // 3. The mount path of the authentication method (e.g. `auth/oidc/github`).
                        // 4. The mount path of the secret store (e.g. `secrets/parsec-keys`).
                        // 5. The path of the secret within the secret store.
                        //
                        // However all those info are not stored in (and hence obtained from) this
                        // device keys file since it would make them complex to change in the future.
                        // So instead the OpenBao server configuration (i.e. server address, list
                        // of supported authentication methods, mount paths) is to be obtained
                        // from the Parsec server each time we need to load this device keys file.
                        {
                            // Arbitrary field only used by the GUI.
                            //
                            // In practice, it is expected to contain a `OpenBaoAuthType`
                            // corresponding to the authentication method that have been used
                            // to authenticate to OpenBao during the creation of this device keys file.
                            //
                            // The idea here is to allow the GUI to use this again during subsequent
                            // access of this device keys file in order to pre-select the
                            // authentication method that should be used.
                            //
                            // Note we use a string instead of directly a `OpenBaoAuthType` for backward
                            // compatibility (given, even if the auth ID is unknown, we could still
                            // be able to decrypt this device file if the user can authenticate to
                            // OpenBao using a different SSO auth).
                            "name": "openbao_preferred_auth_id",
                            "type": "String"
                        },
                        {
                            // Entity ID basically correspond to an account ID in OpenBao.
                            // So the GUI should authenticate as this entity in OpenBao in order
                            // to be able to fetch the secret containing the ciphertext key.
                            "name": "openbao_entity_id",
                            "type": "String"
                        },
                        {
                            // The ciphertext key is stored in OpenBao as a secret that is has
                            // for path `<entity_id>/<ciphertext key UUID>`.
                            //
                            // Note we don't just use the ciphertext key UUID as path since OpenBao
                            // is expected to be configured with path-based access policy (i.e.
                            // a given entity is only allowed to access the secrets starting with
                            // its entity ID).
                            "name": "openbao_ciphertext_key_path",
                            "type": "String"
                        }
                    ]
                }
            ]
        }
    ]
}
