// Parsec Cloud (https://parsec.cloud) Copyright (c) BUSL-1.1 (eventually AGPL-3.0) 2016-present Scille SAS

//! Send Authenticated commands to the server.
//!
//! The HTTP-request will contain the following headers for authentication:
//!
//! ```text
//! Authorization: PARSEC-SIGN-ED25519
//! Author: [base64 string]
//! Timestamp: [DateTime UTC RFC3339 with millisecond]
//! Signature: [base64 ed25519 signature]
//! ```
//! The signature is generated by appending the following data:
//!
//! 1. `author` (in base64, contains in header `Author`)
//! 2. `timestamp` (date time UTC RFC3339 with millisecond, contains in header `Timestamp`)
//! 3. `body` (the http body in bytes)
//!
//! # Why using rfc 3339 instead of rfc 2822 ?
//!
//! > Because I can, that's why
//! > @me
//!
//! The reasons are listed [here](https://datatracker.ietf.org/doc/html/rfc3339#section-5)
//!
//! 1. Ordering
//! 2. Tradeoff between human readability and interoperability
//! 3. Redundant information (i.e.: we don't need the day of week)
//!
//! Beside the headers for authentication, we also add the header `API_VERSION` that contain the [parsec_api_protocol::ApiVersion]
//!

use base64::prelude::{Engine, BASE64_STANDARD};
use bytes::Bytes;
use reqwest::{
    header::{HeaderMap, HeaderValue, AUTHORIZATION, CONTENT_LENGTH, CONTENT_TYPE},
    Client, RequestBuilder, Url,
};
#[cfg(not(target_arch = "wasm32"))]
use reqwest_eventsource::{Event as SSEEvent, EventSource};
use std::{fmt::Debug, marker::PhantomData};
use std::{path::Path, sync::Arc};

use libparsec_platform_http_proxy::ProxyConfig;
use libparsec_protocol::{api_version_major_to_full, API_LATEST_MAJOR_VERSION};
use libparsec_types::prelude::*;

#[cfg(feature = "test-with-testbed")]
use crate::testbed::{get_send_hook, SendHookConfig};
use crate::{
    error::{ConnectionError, ConnectionResult},
    API_VERSION_HEADER_NAME, PARSEC_CONTENT_TYPE,
};

/// Method name that will be used for the header `Authorization` to indicate that will be using this method.
pub const PARSEC_AUTH_METHOD: &str = "PARSEC-SIGN-ED25519";

pub struct SSEStream<T>
where
    T: ProtocolRequest<API_LATEST_MAJOR_VERSION> + Debug + 'static,
{
    #[cfg(not(target_arch = "wasm32"))]
    event_source: EventSource,
    phantom: PhantomData<T>,
}

impl<T> Debug for SSEStream<T>
where
    T: ProtocolRequest<API_LATEST_MAJOR_VERSION> + Debug + 'static,
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("SSEStream").finish()
    }
}

#[derive(Debug, PartialEq, Eq)]
pub enum SSEResponseOrMissedEvents<T>
where
    T: ProtocolRequest<API_LATEST_MAJOR_VERSION> + Debug + 'static,
{
    Response(T::Response),
    MissedEvents,
}

impl<T> SSEStream<T>
where
    T: ProtocolRequest<API_LATEST_MAJOR_VERSION> + Debug + 'static,
{
    #[cfg(target_arch = "wasm32")]
    pub async fn next(&mut self) -> Result<SSEResponseOrMissedEvents<T>, ConnectionError> {
        todo!();
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub async fn next(&mut self) -> Result<SSEResponseOrMissedEvents<T>, ConnectionError> {
        loop {
            match self.next_sse_event().await? {
                SSEEvent::Open => {
                    // Should occur only once, just ignore it
                    continue;
                }
                SSEEvent::Message(event) => {
                    match event.event.as_ref() {
                        "missed_events" => return Ok(SSEResponseOrMissedEvents::MissedEvents),
                        "message" => {
                            if let Ok(raw_rep) = BASE64_STANDARD.decode(event.data) {
                                if let Ok(rep) = T::api_load_response(raw_rep.as_ref()) {
                                    return Ok(SSEResponseOrMissedEvents::Response(rep));
                                }
                            }
                            return Err(ConnectionError::BadContent);
                        }
                        // Ignore the rest
                        _ => continue,
                    }
                }
            }
        }
    }

    #[cfg(not(target_arch = "wasm32"))]
    async fn next_sse_event(&mut self) -> Result<SSEEvent, ConnectionError> {
        use futures::stream::StreamExt;
        match self.event_source.next().await {
            Some(Ok(sse_event)) => Ok(sse_event),
            Some(Err(err)) => match err {
                reqwest_eventsource::Error::Transport(err) => {
                    Err(ConnectionError::NoResponse(Some(err)))
                }
                // All statuses except 200
                reqwest_eventsource::Error::InvalidStatusCode(status_code) => {
                    match status_code.as_u16() {
                        415 => Err(ConnectionError::BadContent),
                        // TODO: cannot  access the response headers here...
                        // 422 => Err(crate::error::unsupported_api_version_from_headers(
                        //     resp.headers(),
                        // )),
                        460 => Err(ConnectionError::ExpiredOrganization),
                        461 => Err(ConnectionError::RevokedUser),
                        // We typically use HTTP 503 in the tests to simulate server offline,
                        // so it should behave just like if we were not able to connect
                        503 => Err(ConnectionError::NoResponse(None)),
                        _ => Err(ConnectionError::InvalidResponseStatus(status_code)),
                    }
                }
                reqwest_eventsource::Error::StreamEnded => Err(ConnectionError::NoResponse(None)),
                _ => Err(ConnectionError::BadContent),
            },
            None => Err(ConnectionError::NoResponse(None)),
        }
    }

    #[allow(unused_mut)]
    pub fn close(mut self) {
        #[cfg(not(target_arch = "wasm32"))]
        self.event_source.close();
    }
}

/// Factory that send commands in a authenticated context.
#[derive(Debug)]
pub struct AuthenticatedCmds {
    /// HTTP Client that contain the basic configuration to communicate with the server.
    client: Client,
    url: Url,
    device: Arc<LocalDevice>,
    author_header_value: HeaderValue,
    #[cfg(feature = "test-with-testbed")]
    send_hook: SendHookConfig,
}

impl AuthenticatedCmds {
    pub fn new(
        config_dir: &Path,
        device: Arc<LocalDevice>,
        proxy: ProxyConfig,
    ) -> anyhow::Result<Self> {
        let client = {
            let builder = reqwest::ClientBuilder::default();
            let builder = proxy.configure_http_client(builder);
            builder.build()?
        };
        Ok(Self::from_client(client, config_dir, device))
    }

    pub fn from_client(client: Client, _config_dir: &Path, device: Arc<LocalDevice>) -> Self {
        let url = device.organization_addr.to_authenticated_http_url();

        #[cfg(feature = "test-with-testbed")]
        let send_hook = get_send_hook(_config_dir);

        let author_header_value =
            HeaderValue::from_str(&BASE64_STANDARD.encode(device.device_id.to_string().as_bytes()))
                .expect("base64 shouldn't contain invalid char");

        Self {
            client,
            url,
            device,
            author_header_value,
            #[cfg(feature = "test-with-testbed")]
            send_hook,
        }
    }

    pub fn addr(&self) -> &BackendOrganizationAddr {
        &self.device.organization_addr
    }

    // Just used for test
    #[cfg(not(target_arch = "wasm32"))]
    pub async fn start_sse_and_wait_for_connection<T>(
        &self,
    ) -> Result<SSEStream<T>, ConnectionError>
    where
        T: ProtocolRequest<API_LATEST_MAJOR_VERSION> + Debug + 'static,
    {
        let mut sse = self.start_sse();
        let first_event = sse.next_sse_event().await?;
        assert!(matches!(first_event, SSEEvent::Open,));
        Ok(sse)
    }

    #[cfg(target_arch = "wasm32")]
    pub async fn start_sse_and_wait_for_connection<T>(
        &self,
    ) -> Result<SSEStream<T>, ConnectionError>
    where
        T: ProtocolRequest<API_LATEST_MAJOR_VERSION> + Debug + 'static,
    {
        todo!()
    }

    #[cfg(target_arch = "wasm32")]
    pub fn start_sse<T>(&self) -> SSEStream<T>
    where
        T: ProtocolRequest<API_LATEST_MAJOR_VERSION> + Debug + 'static,
    {
        todo!()
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub fn start_sse<T>(&self) -> SSEStream<T>
    where
        T: ProtocolRequest<API_LATEST_MAJOR_VERSION> + Debug + 'static,
    {
        let request_builder = {
            let url = {
                let mut url = self.url.clone();
                let mut psm = url
                    .path_segments_mut()
                    .expect("url is not a cannot-be-a-base");
                psm.push("events");
                drop(psm);
                url
            };

            let request_builder = self.client.get(url);
            let request_builder = sign_request(
                request_builder,
                &self.device.signing_key,
                self.author_header_value.clone(),
                b"",
            );

            let mut content_headers = HeaderMap::with_capacity(2);
            let api_version = api_version_major_to_full(T::API_MAJOR_VERSION);
            content_headers.insert(
                API_VERSION_HEADER_NAME,
                HeaderValue::from_str(&api_version.to_string())
                    .expect("api version must contains valid char"),
            );
            // No Content-Type as this request is a GET
            content_headers.insert(
                CONTENT_LENGTH,
                HeaderValue::from_str("0").expect("numeric value are valid char"),
            );
            request_builder.headers(content_headers)
        };

        let event_source =
            EventSource::new(request_builder).expect("provided request builder is clonable");

        SSEStream::<T> {
            event_source,
            phantom: PhantomData,
        }
    }

    pub async fn send<T>(&self, request: T) -> ConnectionResult<<T>::Response>
    where
        T: ProtocolRequest<API_LATEST_MAJOR_VERSION> + Debug + 'static,
    {
        #[cfg(feature = "test-with-testbed")]
        let request = {
            match self.send_hook.high_level_send(request).await {
                crate::testbed::HighLevelSendResult::Resolved(rep) => return rep,
                crate::testbed::HighLevelSendResult::PassToLowLevel(req) => req,
            }
        };

        let request_body = request.api_dump()?;

        // Split non-generic code out of `send` to limit the amount of code generated
        // by monomorphization
        let api_version = api_version_major_to_full(T::API_MAJOR_VERSION);
        let response_body = self.internal_send(api_version, request_body).await?;

        Ok(T::api_load_response(&response_body)?)
    }

    async fn internal_send(
        &self,
        api_version: &ApiVersion,
        request_body: Vec<u8>,
    ) -> Result<Bytes, ConnectionError> {
        let api_version_header_value = HeaderValue::from_str(&api_version.to_string())
            .expect("api version must contains valid char");
        let request_builder = self.client.post(self.url.clone());

        let req = prepare_request(
            request_builder,
            &self.device.signing_key,
            self.author_header_value.clone(),
            api_version_header_value,
            request_body,
        );

        #[cfg(feature = "test-with-testbed")]
        let resp = self.send_hook.low_level_send(req).await?;
        #[cfg(not(feature = "test-with-testbed"))]
        let resp = req.send().await?;

        match resp.status().as_u16() {
            200 => {
                let response_body = resp.bytes().await?;
                Ok(response_body)
            }
            415 => Err(ConnectionError::BadContent),
            422 => Err(crate::error::unsupported_api_version_from_headers(
                resp.headers(),
            )),
            460 => Err(ConnectionError::ExpiredOrganization),
            461 => Err(ConnectionError::RevokedUser),
            // We typically use HTTP 503 in the tests to simulate server offline,
            // so it should behave just like if we were not able to connect
            503 => Err(ConnectionError::NoResponse(None)),
            _ => Err(ConnectionError::InvalidResponseStatus(resp.status())),
        }
    }
}

/// Prepare a new request, the body will be added to the Request using [RequestBuilder::body]
fn prepare_request(
    request_builder: RequestBuilder,
    signing_key: &SigningKey,
    author_header_value: HeaderValue,
    api_version_header_value: HeaderValue,
    body: Vec<u8>,
) -> RequestBuilder {
    let request_builder = sign_request(request_builder, signing_key, author_header_value, &body);

    let mut content_headers = HeaderMap::with_capacity(3);
    content_headers.insert(API_VERSION_HEADER_NAME, api_version_header_value);
    content_headers.insert(CONTENT_TYPE, HeaderValue::from_static(PARSEC_CONTENT_TYPE));
    content_headers.insert(
        CONTENT_LENGTH,
        HeaderValue::from_str(&body.len().to_string()).expect("numeric value are valid char"),
    );

    request_builder.headers(content_headers).body(body)
}

/// Sing a request by adding specific headers.
fn sign_request(
    request_builder: RequestBuilder,
    signing_key: &SigningKey,
    author_header_value: HeaderValue,
    body: &[u8],
) -> RequestBuilder {
    let timestamp = chrono::Utc::now().to_rfc3339_opts(chrono::SecondsFormat::Millis, true);
    let signature = signing_key.sign_only_signature(body);
    let signature = BASE64_STANDARD.encode(signature);

    let mut authorization_headers = HeaderMap::with_capacity(4);

    authorization_headers.insert(AUTHORIZATION, HeaderValue::from_static(PARSEC_AUTH_METHOD));
    authorization_headers.insert("Author", author_header_value);
    authorization_headers.insert(
        "Timestamp",
        HeaderValue::from_str(&timestamp)
            .expect("should contain only numeric char which are valid char"),
    );
    authorization_headers.insert(
        "Signature",
        HeaderValue::from_str(&signature).expect("base64 shouldn't contain invalid char"),
    );

    request_builder.headers(authorization_headers)
}
