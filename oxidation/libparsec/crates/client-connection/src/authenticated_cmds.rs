//! Send Authenticated commands to the server.
//!
//! The HTTP-request will contain the following headers:
//!
//! ```text
//! Authorization: PARSEC-SIGN-ED25519
//! Author: [base64 string]
//! Timestamp: [timestamp in millisecond]
//! Signature: [base64 ed25519 signature]
//! ```
//! The signature is generated by appending the following data:
//!
//! 1. `author` (in base64)
//! 2. `timestamp` (u128 in big-endian)
//! 3. `body` (as bytes)

use protocol::authenticated_cmds;
use types::UserID;
use reqwest::{
    header::{HeaderMap, HeaderValue},
    Client, RequestBuilder, Url,
};

pub const AUTHENTICATED_API_URI: &str = "/authenticated";
/// Method name that will be used for the header `Authorization` to indicate that will be using this method
pub const PARSEC_AUTH_METHOD: &str = "PARSEC-SIGN-ED25519";

/// Factory that send commands in a authenticated context.
pub struct AuthenticatedCmds {
    /// HTTP Client that contain the basic configuration to communicate with the server.
    client: Client,
    user_id: String,
    url: Url,
}

impl AuthenticatedCmds {
    /// Create a new `AuthenticatedCmds`
    pub fn new(client: Client, root_url: &str, user_id: &[u8]) -> Result<Self, url::ParseError> {
        let root_url = Url::parse(root_url)?;
        let url = root_url.join(AUTHENTICATED_API_URI)?;
        let user_id = base64::encode(user_id);

        Ok(Self {
            client,
            user_id,
            url,
        })
    }

    /// Prepare a new request, the body will be added to the Request using [RequestBuilder::body]
    fn prepare_request(&self, body: Vec<u8>) -> RequestBuilder {
        use std::time::SystemTime;

        let timestamp = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .expect("Clock may have gone backwards but not before the EPOCH")
            .as_millis();
        let signature = "foo".to_string();
        let mut authorization_headers = HeaderMap::with_capacity(4); // we will be adding 4 field.

        authorization_headers.insert(
            "Authorization",
            HeaderValue::from_static(PARSEC_AUTH_METHOD),
        );
        authorization_headers.insert(
            "Author",
            HeaderValue::from_str(&self.user_id).expect("base64 shouldn't contain invalid char"),
        );
        authorization_headers.insert(
            "Timestamp",
            HeaderValue::from_str(&timestamp.to_string())
                .expect("should contain only numeric char which are valid char"),
        );
        authorization_headers.insert(
            "Signature",
            HeaderValue::from_str(&signature).expect("base64 shouldn't contain invalid char"),
        );

        self.client
            .post(self.url.clone())
            .headers(authorization_headers)
            .body(body)
    }
}

impl AuthenticatedCmds {
    /// Retrieve the user identified by `id`
    pub async fn user_get(&self, id: UserID) -> authenticated_cmds::user_get::Rep {
        let data = authenticated_cmds::user_get::Req { user_id: id }
            .dump()
            .unwrap();
        let req = self.prepare_request(data).send();
        let resp = req.await.unwrap();
        let response_body = resp.bytes().await.unwrap();
        authenticated_cmds::user_get::Rep::load(&response_body)
    }
}
