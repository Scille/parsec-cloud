# Parsec Cloud (https://parsec.cloud) Copyright (c) AGPLv3 2019 Scille SAS

from typing import Tuple, Optional
import pendulum
from pendulum import Pendulum

from parsec.types import DeviceID, UserID
from parsec.serde import SerdeError, Serializer, UnknownCheckedSchema, fields
from parsec.crypto import (
    CryptoError,
    VerifyKey,
    SigningKey,
    PublicKey,
    sign_and_add_meta,
    verify_signature_from,
    unsecure_extract_msg_from_signed,
    decode_signedmeta,
)


class TrustChainError(Exception):
    pass


class TrustChainInvalidDataError(TrustChainError):
    pass


class TrustChainTooOldError(TrustChainError):
    pass


class TrustChainBrokenChainError(TrustChainError):
    pass


# TODO: configurable ?
MAX_TS_BALLPARK = 30 * 60


def timestamps_in_the_ballpark(ts1: Pendulum, ts2: Pendulum) -> bool:
    """
    Useful to compare timestamp provided inside the certified payload and
    the one generated by the backend when it received the certified payload.
    """
    return abs((ts1 - ts2).total_seconds()) < MAX_TS_BALLPARK


class CertifiedDeviceSchema(UnknownCheckedSchema):
    type = fields.CheckedConstant("device", required=True)
    timestamp = fields.DateTime(required=True)
    device_id = fields.DeviceID(required=True)
    verify_key = fields.VerifyKey(required=True)


class CertifiedUserSchema(UnknownCheckedSchema):
    type = fields.CheckedConstant("user", required=True)
    timestamp = fields.DateTime(required=True)
    user_id = fields.UserID(required=True)
    public_key = fields.PublicKey(required=True)


class CertifiedDeviceRevocationSchema(UnknownCheckedSchema):
    type = fields.CheckedConstant("device_revocation", required=True)
    timestamp = fields.DateTime(required=True)
    device_id = fields.DeviceID(required=True)


certified_device_schema = Serializer(CertifiedDeviceSchema)
certified_user_schema = Serializer(CertifiedUserSchema)
certified_device_revocation_schema = Serializer(CertifiedDeviceRevocationSchema)


def _validate_certified_payload(
    schema: UnknownCheckedSchema, certifier_key: VerifyKey, payload: bytes, now: Pendulum = None
) -> dict:
    """
    Raises:
        TrustChainInvalidDataError
        TrustChainTooOldError
    """
    try:
        raw = verify_signature_from(certifier_key, payload)
        data = schema.loads(raw)

    except (CryptoError, SerdeError) as exc:
        raise TrustChainInvalidDataError(*exc.args) from exc

    if not timestamps_in_the_ballpark(data["timestamp"], now or pendulum.now()):
        raise TrustChainTooOldError("Timestamp is too old.")

    return data


def certify_device(
    certifier_id: Optional[DeviceID],
    certifier_key: SigningKey,
    device_id: DeviceID,
    verify_key: VerifyKey,
    now: Pendulum = None,
) -> bytes:
    """
    Raises:
        TrustChainInvalidDataError
    """
    try:
        payload = certified_device_schema.dumps(
            {
                "type": "device",
                "timestamp": now or pendulum.now(),
                "device_id": device_id,
                "verify_key": verify_key,
            }
        )
        return sign_and_add_meta(certifier_id, certifier_key, payload)

    except (CryptoError, SerdeError) as exc:
        raise TrustChainInvalidDataError(*exc.args) from exc


def validate_payload_certified_device(
    certifier_key: VerifyKey, payload: bytes, now: Pendulum
) -> dict:
    """
    Raises:
        TrustChainInvalidDataError
        TrustChainTooOldError
    """
    return _validate_certified_payload(certified_device_schema, certifier_key, payload, now)


def unsecure_certified_device_extract_verify_key(data: bytes) -> VerifyKey:
    """
    Raises:
        TrustChainInvalidDataError
    """
    try:
        _, signed = decode_signedmeta(data)
        raw = unsecure_extract_msg_from_signed(signed)
        return certified_device_schema.loads(raw)["verify_key"]

    except (CryptoError, SerdeError) as exc:
        raise TrustChainInvalidDataError(*exc.args) from exc


def certify_user(
    certifier_id: Optional[DeviceID],
    certifier_key: SigningKey,
    user_id: UserID,
    public_key: PublicKey,
    now: Pendulum = None,
) -> bytes:
    """
    Raises:
        TrustChainInvalidDataError
    """
    try:
        payload = certified_user_schema.dumps(
            {
                "type": "user",
                "timestamp": now or pendulum.now(),
                "user_id": user_id,
                "public_key": public_key,
            }
        )
        return sign_and_add_meta(certifier_id, certifier_key, payload)

    except (CryptoError, SerdeError) as exc:
        raise TrustChainInvalidDataError(*exc.args) from exc


def validate_payload_certified_user(
    certifier_key: VerifyKey, payload: bytes, now: Pendulum
) -> dict:
    """
    Raises:
        TrustChainInvalidDataError
        TrustChainTooOldError
    """
    return _validate_certified_payload(certified_user_schema, certifier_key, payload, now)


def unsecure_certified_user_extract_public_key(data: bytes) -> PublicKey:
    """
    Raises:
        TrustChainInvalidDataError
    """
    try:
        _, signed = decode_signedmeta(data)
        raw = unsecure_extract_msg_from_signed(signed)
        return certified_user_schema.loads(raw)["public_key"]

    except (CryptoError, SerdeError) as exc:
        raise TrustChainInvalidDataError(*exc.args) from exc


def certify_device_revocation(
    certifier_id: DeviceID,
    certifier_key: SigningKey,
    revoked_device_id: DeviceID,
    now: Pendulum = None,
) -> bytes:
    """
    Raises:
        TrustChainInvalidDataError
    """
    try:
        payload = certified_device_revocation_schema.dumps(
            {
                "type": "device_revocation",
                "timestamp": now or pendulum.now(),
                "device_id": revoked_device_id,
            }
        )
        return sign_and_add_meta(certifier_id, certifier_key, payload)

    except (CryptoError, SerdeError) as exc:
        raise TrustChainInvalidDataError(*exc.args) from exc


def validate_payload_certified_device_revocation(
    certifier_key: VerifyKey, payload: bytes, now: Pendulum
) -> dict:
    """
    Raises:
        TrustChainInvalidDataError
        TrustChainTooOldError
    """
    return _validate_certified_payload(
        certified_device_revocation_schema, certifier_key, payload, now
    )


def certified_extract_parts(certified: bytes) -> Tuple[DeviceID, bytes]:
    """
    Raises:
        TrustChainInvalidDataError
    Returns: Tuple of certifier device id and payload
    """
    try:
        return decode_signedmeta(certified)

    except CryptoError as exc:
        raise TrustChainInvalidDataError(*exc.args) from exc


def cascade_validate_devices(
    certified_devices, root_device_id, root_verify_key, now
) -> Tuple[dict]:
    """
    Raises:
        TrustChainBrokenChainError
        TrustChainInvalidDataError
        TrustChainTooOldError
    """

    def _check_current_certifier_match_previous_certifier(current_certifier, previous_certifier):
        if current_certifier != previous_certifier:
            raise TrustChainBrokenChainError(
                f"Device {current_certifier} not signed by {previous_certifier}"
            )

    devices = []
    for certified_device in certified_devices:
        if devices:
            previous_device = devices[-1]
        else:
            previous_device = {
                "device_id": root_device_id,
                "verify_key": root_verify_key.verify_key,
            }
        certifier_id, certified_payload = certified_extract_parts(certified_device)
        _check_current_certifier_match_previous_certifier(
            certifier_id, previous_device["device_id"]
        )
        validated = validate_payload_certified_device(
            previous_device["verify_key"], certified_payload, now
        )
        devices.append(validated)

    return tuple(devices)
