<!-- Parsec Cloud (https://parsec.cloud) Copyright (c) BUSL-1.1 2016-present Scille SAS -->

# Schema for parsec-account

## Overview

This RFC defines the schema used for communicating with the parsec-account service
described in [RFC 1013 Parsec Account](1013-parsec-account.md).

## Goals and Non-Goals

The goal is to define the required schema used when communicating with the parsec-account service.
For simplicity, we will skip the Fido2 part that will be defined in a later RFC.

## Design

### Summary

This RFC proposes to add the commands below to manage _accounts_,
_authentication methods_ and _devices_. All these commands would
be added to a new command family named `account_cmds`.

For the account:
- `account_send_email_validation_token`: get a verification token for a given email
- `account_create`: create an account for a given email
- `account_manifest_get`: get the account manifest for a given authentication method.
- `account_delete`: remove the account and all the data associated to it

For the authentication methods:
- `auth_method_get`: Information related to a given authentication method
- `auth_method_create`: add an authentication method
- `auth_method_delete`: remove an existing authentication method

For the devices managed by the service:
- `device_upload`: upload a new device for an organization
- `device_list`: list all registered devices
- `device_get`: get the encrypted device for a given organization and device ID

### Account creation

To start the account creation, the client start by sending its email.

```yml
{
  "cmd": "account_send_email_validation_token",
  "req": {
    "email": "Email"
  },
  "reps": [
    {
      "status": "ok"
    },
    {
      "status": "invalid_email"
    }
  ]
}
```

On `ok`, the server would have sent a mail with a unique token used for next the request used to register the authentication method.
If the email is already registered in the service, a `ok` response will still be sent (without token creation)
to avoid creating an oracle about emails registered in the service.

```yml
{
  "cmd": "account_create",
  "req": {
    "email_validation_token": "EmailValidationToken",
    "account_manifest": "EncryptedAccountManifest",
    "auth_method": "AuthMethod"
  },
  "reps": [
    {
      "status": "ok",
    },
    {
      "status": "invalid_email_validation_token"
    }
  ]
}
```

With `AuthMethod` defined like so:

```yml
{
  "label": "AuthMethod",
  "type": "auth_method",
  "other_fields": {
    "id": "AuthMethodID",
    # The symmetric key used to encrypt the manifest
    # that was encrypted using the public key of the authentication method.
    "account_manifest_encrypted_sym_key": "EncryptedSymKey",
    # The shared secret between the client and server using for the HMAC authentication.
    "hmac_key": "HMACKey",
    # The private key of the authentication method encrypted with `auth_method_sym_key`.
    "encrypted_priv_key": "EncryptedPrivKey",
    # The parameters used to generate the symmetric key for the authentication method.
    "sym_key_params": "KeyAlgorithm"
  }
}
```

`EncryptedAccountManifest`, `EncryptedSymKey`, `HMACKey`, `EncryptedPrivKey` are specialized `Bytes` types.

`EncryptedAccountManifest` is generated by encrypting the following data structure:

```yml
{
  "label": "AccountManifest",
  "type": "account_manifest",
  "other_fields": {
    # List of registered auth methods for the account.
    #
    # The account manifest is itself encrypted for each auth method,
    # hence we need those keys to be able to re-encrypt it every time
    # it is modified (i.e. when adding/removing a device/auth medium).
    "per_auth_method_pub_key": "HashMap<AuthMethodID, PublicKey>",
    # Each device is stored on the server encrypted with it own symmetric key.
    # Note we call this key "decryption" even if it's a symmetric one since the device
    # never gets re-encrypted and hence the key is only used to decrypt it.
    "per_device_decryption_keys": "HashMap<(OrganizationID, DeviceID), SymmetricKey>"
  }
}
```

### Obtain the account manifest

Before obtaining the encrypted account manifest, the user retrieves the information related to its authentication method:

```yml
{
  "cmd": "auth_method_get",
  "req": {
    "id": "AuthMethodID"
  },
  "reps": [
    {
      "status": "ok",
      # Parameters used to generate the symmetric key for the authentication method.
      "sym_key_params": "KeyAlgorithm",
      # The auth method private key, encrypted with `auth_method_sym_key`.
      "encrypted_priv_key": "EncryptedPrivKey",
      # The account manifest symmetric key encrypted with `auth_method_pub_key`.
      "account_manifest_sym_key": "EncryptedSymKey",
      # The account manifest related to the authentication method.
      "account_manifest_id": "AccountManifestID",
    }
  ]
}
```

Then retrieve the account manifest using the provided `account_manifest_id`:

```yml
{
  "cmd": "account_manifest_get",
  "req": {
    "id": "AccountManifestID",
    # Allow to retrieve the manifest at a specific version.
    # If not provided, will return the latest version.
    "version": "Option<UInt>"
  },
  "reps": [
    {
      "status": "ok",
      "manifest": "AccountManifestEntry"
    },
    {
      "status": "unknown_manifest_id"
    },
    {
      "status": "unknown_manifest_version"
    }
  ]
}
```

`AccountManifestEntry` is structured like so:

```yml
{
  "label": "AccountManifestEntry",
  "type": "account_manifest_entry",
  "other_fields": {
    # The ID of the account manifest
    "id": "Uuid",
    # The version of the account manifest
    "version": "UInt",
    # The account manifest encrypted with `account_manifest_sym_key`
    "encrypted_manifest": "EncryptedAccountManifest",
  }
}
```

### Uploading a new device

Now that the client can encrypt the device with the symmetric key, it can upload it:

```yml
{
  "cmd": "device_upload",
  "req": {
    "account_manifest": "AccountManifestEntry"
    "organization_id": "OrganizationID",
    "device_ownership_proof": "DeviceOwnershipProof",
    "encrypted_device": "EncryptedDevice"
  },
  "reps": [
    {
      "status": "ok"
    },
    {
      "status": "auth_method_mismatch"
    },
    {
      "status": "invalid_ownership_proof"
    },
    {
      # The version does not respect `next_version > current_version`.
      # Where `current_version` is the latest version registered in the server (that would indicate concurrent change)
      "status": "invalid_manifest_version"
    }
  ]
}
```

> [!NOTE]
> The user can upload multiple devices for the same organization.

### List available devices

To list the devices registered in the service, the client only needs to be authenticated:

```yml
{
  "cmd": "device_list",
  "req": {},
  "reps": [
    {
      "status": "ok",
      "devices": "Vec<DeviceInfo>"
    }
  ],
  "custom_types": {
    "DeviceInfo": {
      "organization_id": "OrganizationID",
      "device_id": "DeviceID",
      "user_id": "UserID",
      "human_handle": "HumanHandle",
      "created_on": "DateTime",
      "revoked_on": "Option<DateTime>"
    }
  }
}
```

### Retrieve device

To retrieve the encrypted device, the client simply has to provide the organization ID:

```yml
{
  "cmd": "device_get",
  "req": {
    "organization_id": "OrganizationId",
    "device_id": "DeviceID"
  },
  "reps": [
    {
      "status": "ok",
      "encrypted_device": "EncryptedDevice"
    },
    {
      "status": "device_not_found"
    }
  ]
}
```

### Adding a new authentication method

To add a new authentication method, the client just needs to provide the required information:

```yml
{
  "cmd": "auth_method_create",
  "req": {
    "auth_method": "AuthMethod",
    "account_manifest": "AccountManifestEntry",
    "delete_auth_method_id": "Option<AuthMethodID>",
    "per_auth_method_encrypted_account_manifest_sym_key": "HashMap<AuthMethodID, EncryptedSymKey>"
  },
  "reps": [
    {
      "status": "ok"
    },
    {
      "status": "auth_method_not_found"
    },
    {
      "status": "per_auth_method_encrypted_account_manifest_sym_key_mismatch"
    }
  ]
}
```

> `delete_auth_method_id` is optional and can be used to delete the authentication method identified by the ID.

### Removing an authentication method

To remove an authentication method

```yml
{
  "cmd": "auth_method_delete",
  "req": {
    "auth_method_id": "AuthMethodID",
    "account_manifest": "AccountManifestEntry",
    "per_auth_method_encrypted_account_manifest_sym_key": "HashMap<AuthMethodID, EncryptedSymKey>"
  },
  "reps": [
    {
      "status": "ok"
    },
    {
      "status": "auth_method_not_found"
    },
    {
      "status": "cannot_delete_last_auth_method"
    }
  ]
}
```

### Deleting the account

To delete the account, the client needs to be authenticated and provide the derived password:

```yml
{
  "cmd": "account_delete",
  "req": {},
  "reps": [
    {
      "status": "ok"
    }
  ]
}
```
