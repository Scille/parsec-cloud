<!-- Parsec Cloud (https://parsec.cloud) Copyright (c) BUSL-1.1 2016-present Scille SAS -->

# Collaborative edition via CryptPad

## Overview

This RFC describes how to enable collaborative edition in Parsec via [CryptPad](https://cryptpad.org/).

## Background & Motivation

CryptPad is fully end-to-end encrypted and doesn't know anything about Parsec users, so it cannot manage
access-rights with user sessions. Editing sessions are based exclusively on *session keys*: either a user knows
the session key and can access the document, or don't.

To manage the session keys, CryptPad API provides 2 alternatives:

1. Keys generated by CryptPad: Parsec is informed via `onNewKey` handler to store and distribute the new key.
2. Keys generated by Parsec: CryptPad won't perform any check and will trust Parsec to rotate keys correctly.

Only the latter is acceptable for Parsec (as CryptPad is not connected to the RBAC system of Parsec), so this RFC focuses on option 2.

### About CryptPad sessions

CryptPad only provides a collaborative session that multiple users can join to edit the same document.

The data is end-to-end encrypted on the CryptPad side but doesn't persist. The integrating service (Parsec) is expected
to manage storage and access rights / sharing keys.

Editing sessions are identified via a *session key*. Users who want to edit the same document would use the same
session key and they will end up in the same session (the first user will create the session, the others will join).

Session keys must be rotated when someone's access to a document has been revoked. This will guarantee they won't
be able to use the session key to extract the document content from CryptPad directly.

CryptPad will automatically destroy the document content after each collaborative session but as long as you know the
key, you can always get the content while a session is online.

When session key changes, CryptPad won't destroy the session instantly but the connected users won't be able to save further changes.

CryptPad only closes the session when all users quit. There is a configurable timeout, before actually closing the
session so it's possible to reconnect to the session for a user having the session key.

## Goals and Non-Goals

The goal is to describe:

- how to correctly **store**, **share** and **rotate the editing session keys** in Parsec.
- how to manage document saves

> [!IMPORTANT]
> We only cater to users who have write access as do lack experience on how CryptPad work with read-only access and how we can generate a session key with that restriction. (See open questions)

## Design

### Session key

In principle, the *editing session key* could be derived from Parsec's *realm key*. Since a key rotation is already
performed by Parsec this seems like a good candidate (see [RFC 1005](1005-realm-key-rotation.md)).

However, there are a couple of nuances related to how Parsec manages profiles and workspace roles and when a key
rotation is actually performed (Only when a user is removed, not on role change).

Requirements for the *editing session key*:

- Must only be shared with writers (i.e.: Not reader role)
- If a writer lose is privilege, the session key can be replaced to prevent access to the editing session
- Can be shared to new writer

#### Session key using a manifest

Introduce a new manifest type `EditingManifest`:

```yaml
label: EditingManifest
type: editing_manifest
other_fields:
- name: created
  type: DateTime
- name: author
  type: DeviceID
- name: related_file
  type: VlobID
- name: version
  type: Version
- name: editing_session_key
  type: HashMap<UserID, Blob>
```

- **editing_session_key**: Correspond to the current editing session_key to join the CryptPad session, but it's encrypted with the public key of all writers identified by `UserID`.

##### `EditingManifest` & Key rotation

When the writers list change (added or removed) or the creation of the manifest is `< now() - CRYPTPAD_SESSION_TIMEOUT * 0.9`, we need to rotate the session key.

> `CRYPTPAD_SESSION_TIMEOUT` is configured on the CryptPad server side, it defines how long a session is keep alive once the last user quit the session.
> That value should be know by the client (the value should be provided by the server as it's can change depending on the CryptPad server)

The rotation is performed by the users currently using the session (and writers wanting to join), everyone will try to generate and shared a new manifest key,
but everyone will have a random jitter (between 100ms-1000ms), the last author will not have such jitter.
The user generating the new session key can only start using only once the server as accepted the new version manifest.
Upon receiving a new manifest the server will send an event to notify users about the updated manifest.
When writers receive that event, they would fetch the new manifest and start using the new session key.

##### `EditingManifest` Pros&Cons

Pros:

- Most of the logic already exist: It's a new manifest
- The session key is unique as randomly generated by the user
- Can be extended to include a reader session key later on

Cons:

- The session key remains valid in case of realm key rotation
- Not automatically shared with new writers
- The session key cannot be known by other writers ahead of time


#### Session key using a shared secret

Introduce a new secret only shared among the writers (i.e.: not reader role) that is used to derive the **editing_session_key**.
That secret would require a new rotation system when the list of writers change (added or removed) but in case of addition, the current secret could be shared to the new writer.

> In short, it's a realm key rotation, but only for writers.

##### Derive the session key

If a writer needs to access the editing session, it would derive the **editing_session_key** from the following inputs:

- Shared secret
- The `EntryID` of the file (That make the key unique per file)
- `now() // CRYPTPAD_SESSION_TIMEOUT * 0.9` (That make the key unique in time)

Given we include a time parameter, the user should periodically generate a new session key (every `CRYPTPAD_SESSION_TIMEOUT * 0.9`)

##### Shared secret Pros&Cons

Pros:

- Known by other writers ahead of time

Cons:

- Cannot be extended to include a reader session key later on
- Need to add a new key rotation system

#### Replace the encryption&signature of CryptPad with Parsec

### Document Save

CryptPad dispatch `onSave` event, it's apparently the last user who made a change that will receive the event.

> We consider that only a single user will receive such event, and we will not have to handle concurrent save.

During the `onSave` event, CryptPad provide the full document up-to-date to save.
For that reason would be best to introduce a differential saving (e.i: compare old vs new to only save changed block, or not save at all if identical)

> The comparison could be on the whole file or block per block if we want more granularity on the uploaded blocks.

In the bindings, we likely want to expose a function to do that:

```rust
/// Compare `new_content` with current content of file at `path` and only register the modified block if any.
/// It always compare against the latest known version of the file.
fn workspace_differential_save(workspace_id: WorkspaceID, path: &Path, new_content: &[u8]) {}
```

## Security/Privacy/Compliance

> What security/privacy/compliance aspects should be considered?
> If you're not certain, never assume there arenâ€™t any. Always talk to the security team.

## Risks

- CryptPad provide a system to share a document and the deployed server MUST have that feature disabled
- CryptPad instances do not forbid users to connect directly to them. This needs further analysis
  since security measures applied by Parsec could be easily by-passed.
- A user saving a document may not be the one who made the modification.

## Remarks & open questions

- Internally, CryptPad uses 2 kind of keys:

  - A symmetric encryption key, used to encrypt and decrypt the document data.
  - An asymmetric signing key, only used by user who have write access to sign there modifications. The public part is know to everyone in the session.

  > From [CryptPad encryption]

  That explain how CryptPad is able to provide [read-only permission](https://docs.cryptpad.org/en/user_guide/share_and_access.html#access) on a file. But can we do the same?
- Can we replace the session key with another? So during a key rotation the user would not have to re-enter the edition mode
- Does CryptPad prevent concurrent save?

[CryptPad encryption]: https://docs.cryptpad.org/en/dev_guide/general.html#encryption
