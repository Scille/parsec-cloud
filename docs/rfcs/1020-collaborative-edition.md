<!-- Parsec Cloud (https://parsec.cloud) Copyright (c) BUSL-1.1 2016-present Scille SAS -->

# Collaborative edition via CryptPad

## Overview

This RFC describes how to enable collaborative edition in Parsec via [CryptPad](https://cryptpad.org/).

## Background & Motivation

CryptPad is fully end-to-end encrypted and doesn't know anything about Parsec users, so it cannot manage
access-rights with user sessions. Editing sessions are based exclusively on *session keys*: either a user knows
the session key and can access the document, or don't.

To manage the session keys, CryptPad API provides 2 alternatives:

1. Keys generated by CryptPad: Parsec is informed via `onNewKey` handler to store and distribute the new key.
2. Keys generated by Parsec: CryptPad won't perform any check and will trust Parsec to rotate keys correctly.

Only the latter is acceptable for Parsec, so this RFC focuses on option 2.

### About CryptPad sessions

CryptPad only provides a collaborative session that multiple users can join to edit the same document.

The data is end-to-end encrypted on the CryptPad side but doesn't persist. The integrating service (Parsec) is expected
to manage storage and access rights / sharing keys.

Editing sessions are identified via a *session key*. Users who want to edit the same document would use the same
session key and they will end up in the same session (the first user will create the session, the others will join).

Session keys must be rotated when someone's access to a document has been revoked. This will guarantee they won't
be able to use the session key to extract the document content from CryptPad directly.

CryptPad will automatically destroy the document content after each collaborative session but as long as you know the
key, you can always get the content while a session is online.

When session key changes, CryptPad won't destroy the session instantly but the connected users won't be able to save further changes.

CryptPad only closes the session when all users quit. There is a configurable timeout, before actually closing the
session so it's possible to reconnect to the session for a user having the session key.

## Goals and Non-Goals

The goal is to describe:

- how to correctly **store**, **share** and **rotate the editing session keys** in Parsec.
- how to manage document saves

> [!IMPORTANT]
> We only cater to users who have write access as do lack experience on how CryptPad work with read-only access and how we can generate a session key with that restriction. (See open questions)

## Design

### Session key

In principle, the *editing session key* could be derived from Parsec's *realm key*. Since a key rotation is already
performed by Parsec this seems like a good candidate (see [RFC 1005](1005-realm-key-rotation.md)).

However, there are a couple of nuances related to how Parsec manages profiles and workspace roles and when a key
rotation is actually performed (Only when a user is removed, not on role change).

Requirements for the *editing session key*:

- Must only be shared with writers (i.e.: Not reader role)
- If a writer lose is privilege, the session key can be replaced to prevent access to the editing session
- Can be shared to new writer

#### Session key using a manifest

Introduce a new manifest type `EditingManifest`:

```yaml
label: EditingManifest
type: editing_manifest
other_fields:
- name: created
  type: DateTime
- name: author
  type: DeviceID
- name: related_file
  type: VlobID
- name: version
  type: Version
- name: editing_session_key
  type: HashMap<UserID, Blob>
```

- **editing_session_key**: Correspond to the current editing session_key to join the CryptPad session, but it's encrypted with the public key of all writers identified by `UserID`.

##### `EditingManifest` & Key rotation

When the writers list change (added or removed) or the creation of the manifest is `< now() - CRYPTPAD_SESSION_TIMEOUT * 0.9`, we need to rotate the session key.

> `CRYPTPAD_SESSION_TIMEOUT` is configured on the CryptPad server side, it defines how long a session is keep alive once the last user quit the session.
> That value should be know by the client (the value should be provided by the server as it's can change depending on the CryptPad server)

The rotation is performed by the users currently using the session (and writers wanting to join), everyone will try to generate and shared a new manifest key,
but everyone will have a random jitter (between 100ms-1000ms), the last author will not have such jitter.
The user generating the new session key can only start using only once the server as accepted the new version manifest.
Upon receiving a new manifest the server will send an event to notify users about the updated manifest.
When writers receive that event, they would fetch the new manifest and start using the new session key.

##### `EditingManifest` Pros&Cons

Pros:

- Most of the logic already exist: It's a new manifest
- The session key is unique as randomly generated by the user
- Can be extended to include a reader session key later on

Cons:

- The session key remains valid in case of realm key rotation
- Not automatically shared with new writers
- The session key cannot be known by other writers ahead of time


#### Session key using a shared secret

Introduce a new secret only shared among the writers (i.e.: not reader role) that is used to derive the **editing_session_key**.
That secret would require a new rotation system when the list of writers change (added or removed) but in case of addition, the current secret could be shared to the new writer.

> In short, it's a realm key rotation, but only for writers.

##### Derive the session key

If a writer needs to access the editing session, it would derive the **editing_session_key** from the following inputs:

- Shared secret
- The `EntryID` of the file (That make the key unique per file)
- `now() // CRYPTPAD_SESSION_TIMEOUT * 0.9` (That make the key unique in time)

Given we include a time parameter, the user should periodically generate a new session key (every `CRYPTPAD_SESSION_TIMEOUT * 0.9`)

##### Shared secret Pros&Cons

Pros:

- Known by other writers ahead of time

Cons:

- Cannot be extended to include a reader session key later on
- Need to add a now key rotation system

#### Key derivation

The session key would be generated by derivation it from the entry ID of the document (considered unique through a workspace) and a secret (only know to users who have write access).

We have 2 approach to generate the secret:

- During a role change from writer to reader/unshared (and vice-versa), but that require to have a system to only share it with the users who have write access.

  This is a deterministic approach, as everyone (who can write) can generate the session key with information that it already know
  and does not require an additional system to handle concurrency (as it's handle by the realm key rotation system).

- Randomly generated when a user is the first to open a CryptPad session.

  This system provides random session key that are unique to each session,
  it cannot be determined by other users so we need to add a system to share the keys among them.

  Given that we need to shared something only to a subgroup of the workspace, we need to do it securely.
  So we need to encrypt it: If encryption secret is the realm key, it would require the server to perform some access check on the data.
  Or we use a dedicated secret, but we fall back to the first approach.

#### Key rotation

As seen before, performing a key rotation on the *session key* is equivalent to "revoking" the editing session.
Users may remain connected, but they won't be able to save further changes.

This sections analyzes the need for session key rotation in the context of Parsec.

##### Key rotation - No editing sessions

It might seem obvious that if there are no editing sessions currently open, there are no session keys to be rotated.

However, note that Parsec will continue to perform key rotations on the realm key as usual (e.g. if a user is revoked).
This should not be an issue.

##### Key rotation - Changes related to a user in the session

In this simple scenario, Alice and Bob collaborate to edit a document. The session key needs to be rotated if:

1. Alice (or Bob) is revoked from the organization.
2. Alice (or Bob) is "unshared" from the workspace (its role is *removed*)
3. Alice (or Bob) role changes from `Owner` or `Manager` or `Contributor` to `Reader` (or vice-versa)
   - Note that changes between `Owner`, `Manager` and `Contributor` do not require revocation

Parsec will trigger a realm key rotation for 1 and 2, but not for 3. This is because Alice is not supposed to lose
access to the document (only its "can write" status change, i.e. `Contributor` <-> `Reader`).

> TODO: since forcing a realm key rotation does not seem acceptable, this should be managed in some other way: open
> CryptPad session in "read-only" mode? (the user could easily bypass it by connecting directly to CryptPad).
> Derive a new key on role change? how to store it?

##### Key rotation - Changes not related to the users in a session

Following the previous scenario, if the changes are not related to Alice or Bob (e.g. Mallory is revoked or unshared),
a key rotation may still be needed. This is for the same reasons that the realm key is rotated: Mallory **had** access
to the session key, which mean that it would continue having access if no rotation is performed.

Parsec GUI should carefully present this information as it may seem strange for Alice and Bob to be forced to reload
the session due to a key rotation.

#### Key rotation - Share new key

CryptPad does not provides a mechanism to force session closing. This means that in order to share the new key:

- Document saves triggered from users within the existing session **must be disabled**
- All users are informed that a "reload" is needed
- All users are disconnected from the session
  - This will need to be managed by Parsec GUI since CryptPad does not provides a mechanism for this
- CryptPad closes the session after a timeout
- Users are informed of the new key
- A new session is started with the new session key, and users re-join the new session.

We need to ensure that this process is smooth for the Parsec user.

#### Key storage

We need to store a secret that is only know to writers of a workspace.

### Document Save

CryptPad dispatch `onSave` event, it's apparently the last user who made a change that will receive the event.

> We consider that only a single user will receive such event, and we will not have to handle concurrent save.

During the `onSave` event, CryptPad provide the full document up-to-date to save.
For that reason would be best to introduce a differential saving (e.i: compare old vs new to only save changed block, or not save at all if identical)

In the bindings, we likely want to expose a function to do that:

```rust
/// Compare `new_content` with current content of file at `path` and only register the modified block if any.
/// It always compare against the latest known version of the file.
fn workspace_differential_save(workspace_id: WorkspaceID, path: &Path, new_content: &[u8]) {}
```

## Security/Privacy/Compliance

> What security/privacy/compliance aspects should be considered?
> If you're not certain, never assume there arenâ€™t any. Always talk to the security team.

## Risks

- CryptPad instances do not forbid users to connect directly to them. This needs further analysis
  since security measures applied by Parsec could be easily by-passed.
- A user saving a document may not be the one who made the modification.

## Remarks & open questions

- Internally, CryptPad uses 2 kind of keys:

  - A symmetric encryption key, used to encrypt and decrypt the document data.
  - An asymmetric signing key, only used by user who have write access to sign there modifications. The public part is know to everyone in the session.

  > From [CryptPad encryption]

  That explain how CryptPad is able to provide [read-only permission](https://docs.cryptpad.org/en/user_guide/share_and_access.html#access) on a file. But can we do the same?
- Can we replace the session key with another? So during a key rotation the user would not have to re-enter the edition mode
- Does CryptPad prevent concurrent save?

[CryptPad encryption]: https://docs.cryptpad.org/en/dev_guide/general.html#encryption
