<!-- Parsec Cloud (https://parsec.cloud) Copyright (c) BUSL-1.1 2016-present Scille SAS -->

# Account Vault for device stored on server

## 1 - Overview

[RFC 1013](1013-parsec-account.md) quickly describes the Account Vault system,
this RFC goes more in detail regarding the lifecycle and the involved APIs.

### 1.1 - High vs low entropy secrets

Everything that is chosen by a user is considered a low entropy secret. This is because
a human is bad generating and remembering randomness and Parsec cannot enforce [^1] that
best practices (i.e. using password manager) are being used.

[^1]: Parsec GUI prevent user from choosing a weak password, but this doesn't protect against
reused password, easy-to-guess pattern (e.g. using the same complex password for every site,
only with the name of the site appended to it to make it per-site unique...), or improperly
stored password.

On the other hand, everything generated by the computer is considered a high entropy secret (i.e.
we don't question de quality of cryptographic-pseudorandom-number-generator).

We consider acceptable to store highly sensitive data on the server as long as it is protected
by a high entropy secret (as we already do that for e.g. `RealmKeysBundle` & `RealmKeysBundleAccess`).

Considering the ubiquity of password, such low entropy secret cannot just be ruled out.
However we try to limit their usage to the minimum (i.e. Parsec account authentication), and provide
configuration to leave the choice of convenience vs security trade-off [on a per-organization basis](#21---per-organization-vault-storage-strategy).

Password support is especially important for Parsec web, since the web APIs doesn't expose
OS keyring  nor smartcard.

## 2 - Datamodel

### 2.1 - Per-organization vault storage strategy

#### 2.1.1 - Server configuration

Client source strategy is represented in the organization config as an enum:

```json5
{
    "name": "AccountVaultStrategy",
    "variants": [
        {
            "name": "Allowed",
            "discriminant_value": "ALLOWED"
        },
        {
            // The user should not store any data related to this organization
            // server-side using his account vault.
            "name": "Forbidden",
            "discriminant_value": "FORBIDDEN"
        }
    ]
}
```

- Add a `account_vault_strategy` column to the  `organization` table in the datamodel.
- Add `organization_initial_account_vault_strategy` to `BackendConfig`
- Add `--organization-initial-account-vault-strategy` option to run CLI

#### 2.1.2 - Administration API related to organization configuration

Add `account_vault_strategy` fields to:

- `GET /administration/organizations/{raw_organization_id}`
- `PATCH /administration/organizations/{raw_organization_id}`

#### 2.1.3 - Authenticated API `event_listen`

Add `account_vault_strategy` fields to the `OrganizationConfig` event.

```json5
{
    "cmd": "events_listen",

    // Omitted items
    // […]

    "nested_types": [
        {
            "name": "APIEvent",
            "discriminant_field": "event",
            "variants": [
                {
                    // This event is always fired first upon SSE connection
                    "name": "OrganizationConfig",
                    "discriminant_value": "ORGANIZATION_CONFIG",
                    "fields": [

                        // Omitted items
                        // […]

                        {
                            "name": "account_vault_strategy",
                            "type": "AccountVaultStrategy"
                        }
                    ]
                },

                // Omitted items
                // […]
            ]
        },
        {
            "name": "AccountVaultStrategy",
            "variants": [
                {
                    "name": "Allowed",
                    "discriminant_value": "ALLOWED"
                },
                {
                    // The user should not store any data related to this organization
                    // server-side using his account vault.
                    "name": "Forbidden",
                    "discriminant_value": "FORBIDDEN"
                }
            ]
        }
    ]
}
```

### 2.2 - Vault key access

The `vault_key` is encrypted for each authentication method related to the vault.
For this purpose, the `vault_key` is serialized into the `VaultKeyAccess` structure:

```json5
{
    "label": "VaultKeyAccess",
    "type": "vault_key_access",
    "other_fields": [
        {
            "name": "vault_key",
            "type": "SecretKey"
        }
    ]
}
```

> [!NOTE]
> The format of this structure is inspired by the `RealmKeysBundleAccess` structure.

### 2.3 - Vault item

From the server point of view, each vault item is considered opaque.
Hence this `AccountVaultItem` structure that is only handled client-side, and
serialized before being send to the server.

```rust
pub enum AccountVaultItem {
    RegistrationDevice(AccountVaultItemRegistrationDevice)
    WebLocalDeviceKey(AccountVaultItemWebLocalDeviceKey)
}
```

```json5
{
    "label": "AccountVaultItemRegistrationDevice",
    "type": "account_vault_item_auto_enrollment_device",
    "other_fields": [
        {
          "name": "organization_id",
          "type": "OrganizationID"
        },
        // Device ID is not provided here since it is not relevant:
        // this item is only used to give access to this organization/user
        // couple.
        {
        "name": "user_id",
        "type": "UserID"
        },
        {
          // `LocalDevice` encrypted by the vault key
          "name": "encrypted_data",
          "type": "Bytes"
        }
    ]
}
```

```json5
{
    "label": "AccountVaultItemWebLocalDeviceKey",
    "type": "account_vault_item_web_local_device_key",
    "other_fields": [
        {
          "name": "organization_id",
          "type": "OrganizationID"
        },
        // User ID is not provided here since it is not relevant:
        // this item is only used by clients looking to decrypt a given device.
        {
            "name": "device_id",
            "type": "DeviceID"
        },
        {
          // `SecretKey` encrypted by the vault key.
          // This key is itself used to decrypt the `LocalDevice` stored on
          // the web client's LocalStorage.
          "name": "encrypted_data",
          "type": "Bytes"
        }
    ]
}
```

> [!NOTE]
> The rational behind considering vault item opaque is that the server
> cannot control the content of the encrypted data anyway.
> Typically, a malicious client would be able to circumvent the server enforcing
> organization device storage strategy by simply pretending to upload to a
> different organization that allows server-side device storage.

## 5 - APIs

### 5.1 - Add a new vault item

Authenticated account API:

```json5
[
    {
        "major_versions": [
            5
        ],
        "cmd": "vault_item_upload",
        "req": {
            "fields": [
                {
                    "name": "item_fingerprint",
                    // Arbitrary hash of relevant fields of the item to avoid duplicates
                    // Typically for registration device: `hash( 'REGISTRATION_DEVICE' + <organization ID> + <device ID>)`
                    "type": "HashDigest"
                },
                {
                    "name": "item",
                    // Serialized `AccountVaultItem`, the server considers it opaque.
                    "type": "Bytes"
                }
            ]
        },
        "reps": [
            {
                "status": "ok"
            },
            {
                "status": "fingerprint_already_exists"
            }
        ]
    }
]
```

> [!NOTE]
>
> - The vault items are considered opaque from the server point of view, so
>   it doesn't try to enforce checks on the uploaded data (e.g. check that the
>   organization exists, ensure the human handle of the uploaded device corresponds
>   to the email of the account etc.).
> - Similarly, the fingerprint only offers a very basic protection against duplication:
>   it ensure unity of a given item (useful for idempotent upload and knowing which
>   item still needs to be recovered), but not against equivalent items (e.g. two
>   registration devices for the same organization/user couple).
>   This is considered okay considering it is unlikely and not a big deal anyway.
> - Since `VaultKeyAccess` is not encrypted nor signed (only serialized), it can be
>   tempered by the server.
>   For this reason, the client should check the decrypted content against the clear text
>   organization/user/device IDs.
>   Finally having part of the data in clear text is convenient to avoid having to decrypt
>   all items just to display the user the list of available registration devices.

### 5.2 - List vault items

Authenticated account API:

```json5
[
    {
        "major_versions": [
            5
        ],
        "cmd": "vault_item_list",
        "req": {},
        "reps": [
            {
                "status": "ok",
                "fields": [
                    {
                        "name": "key_access",
                        // `VaultKeyAccess` encrypted with the `auth_method_secret_key`
                        "type": "Bytes"
                    },
                    {
                        "name": "items",
                        // Map with `item_fingerprint` as key and serialized `AccountVaultItem` as value
                        "type": "Map<HashDigest, Bytes>"
                    }
                ]
            }
        ]
    }
]
```

### 5.3 - Rotate the vault key

Authenticated account API:

```json5
[
    {
        "major_versions": [
            5
        ],
        "cmd": "vault_key_rotation",
        "req": {
            "fields": [
                {
                    "name": "key_access",
                    // `VaultKeyAccess` encrypted with the `auth_method_secret_key`
                    "type": "Bytes"
                },
                {
                    "name": "items",
                    // Map with `item_fingerprint` as key and serialized `AccountVaultItem` as value
                    "type": "Map<HashDigest, Bytes>"
                }
            ]
        },
        "reps": [
            {
                "status": "ok"
            }
        ]
    }
]
```

Upon receiving this request, the server duplicates the current authentication method
(i.e. the one used to authenticate the current request) and link it to a newly created vault.

> [!IMPORTANT]
> Doing a vault key rotation means switching to a brand new vault. Hence the other
> authentication methods are no longer valid (since they are related to the old vault)
> and therefore would not be able to decrypt the devices encrypted with the new key.

## 5.4 - Recover vault item from older vaults

Authenticated account API:

To list all protected device from all vault except current/active one:

```json5
[
    {
        "major_versions": [
            5
        ],
        "cmd": "vault_item_recovery_list",
        "req": {},
        "reps": [
            {
                "status": "ok",
                "fields": [
                    {
                        "name": "current_vault",
                        "type": "VaultItemRecoveryVault"
                    },
                    {
                        "name": "previous_vaults",
                        "type": "List<VaultItemRecoveryVault>"
                    }
                ]
            }
        ],
        "nested_types": [
            {
                "name": "VaultItemRecoveryVault",
                "fields": [
                    {
                        "name": "auth_methods",
                        "type": "List<VaultItemRecoveryAuthMethod>"
                    },
                    {
                        "name": "vault_items",
                        // Map with `item_fingerprint` as key and serialized `AccountVaultItem` as value
                        "type": "Map<HashDigest, Bytes>"
                    }
                ]
            },
            {
                "name": "VaultItemRecoveryAuthMethod",
                "discriminant_field": "type",
                "variants": [
                    {
                        "name": "Password",
                        "discriminant_value": "PASSWORD",
                        "fields": [
                            {
                                "name": "created_on",
                                "type": "DateTime"
                            },
                            {
                                // TODO: Use `IPAddress` type once implemented
                                // see https://github.com/Scille/parsec-cloud/issues/10384
                                "name": "created_by_ip",
                                "type": "String"
                            },
                            {
                                "name": "created_by_user_agent",
                                "type": "String"
                            },
                            {
                                "name": "vault_key_access",
                                // `VaultKeyAccess` encrypted with the `auth_method_secret_key`
                                "type": "Bytes"
                            },
                            {
                                "name": "algorithm",
                                "type": "PasswordAlgorithm"
                            }
                        ]
                    }
                ]
            },
            {
                "name": "PasswordAlgorithm",
                "discriminant_field": "type",
                "variants": [
                    {
                        "name": "Argon2id",
                        "discriminant_value": "ARGON2ID",
                        "fields": [
                            {
                                "name": "salt",
                                "type": "Bytes"
                            },
                            {
                                "name": "opslimit",
                                "type": "Integer"
                            },
                            {
                                "name": "memlimit_kb",
                                "type": "Integer"
                            },
                            {
                                "name": "parallelism",
                                "type": "Integer"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]
```

Recovery can be done in two ways:

- By remembering a old authentication method's password. Typically the user has changed
  his password, forget the new one (and hence can no longer connect to Parsec Account),
  but still remembers his previous one.
- By recovering the Vault key. For this purpose, we should consider providing a way to export the vault key.
