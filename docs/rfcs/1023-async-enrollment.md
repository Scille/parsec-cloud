<!-- Parsec Cloud (https://parsec.cloud) Copyright (c) BUSL-1.1 2016-present Scille SAS -->

# Asynchronous enrollment

## 1 - Goals

User enrollment into an organization is divided into two steps:

1. Checking the identity of both greeter and claimer.
2. Actually registering the claimer as a member of the organization.

Currently those two steps are done in a synchronous way from the users' point of view:

- Both claimer and greeter must be online at the same time.
- Claimer and greeter have to manually exchange some information (i.e. SAS code exchange).

Those two requirements are needed to fulfill step 1 when both claimer and greeter know
nothing of their respective peer.

However this is not always the case: a 3rd party service may be used to fulfill step 1,
which in turn open the door to an all-automatic enrollment process.

## 2 - Overview

### 2.1 - Submitter/accepter vs claimer/greeter

In regular synchronous enrollment (i.e. the enrollment initiated by an organization admin
inviting a new user, and involving SAS code exchange as identity validation), the two
peers are designed as claimer (the one that wants to be enrolled) and greeter (the one
that does the enrollment).

However this term is changed to submitter & accepter in the asynchronous enrollment.
This is notably to reflect two fundamental differences:

- Any administrator in the organization can deal with any given asynchronous enrollment (while
  there is only a single greeter per synchronous enrollment).
- An asynchronous enrollment is initiated by the submitter (while a synchronous one is
  initiated by the greeter creating an invitation for the new user).

### 2.2 - Workflow

 0. Alice wants to join CoolOrg organization.
 1. Alice uses the organization submission link to submit a request. This submission link
    is specific to the organization and is common to all submit request (typically this
    link can be referenced in a newcomer guide documentation).
 2. Alice authenticates with an external identity system (either connect trough OIDC
    or uses her smartcard containing a PKI identity).
 3. Alice creates a user encryption key pair and a device signing key pair.
 4. Alice saves the private parts of the user & device keys pairs on her machine's filesystem.
    Those data are stored encrypted using the external identity system (e.g. encrypted with smartcard).
 5. Alice sends a request to the Parsec server. This request contains a submit payload and a
    signature that has been achieved using the external identity system.
 6. Bob (a CoolOrg admin) is able to list all the pending enrollment requests
    for the organization.
 7. Bob verifies Alice's request by validating the payload signature, then ensuring the
    signature comes from an identity having the same email than the one specified in the
    submit payload.

    > [!NOTE]
    > The verification implies both Alice and Bob uses the same external identity system.
    > Typically, it is not possible to validate a submit signed with a PKI with an admin
    > that can only authenticate with OIDC.
    > Similarly, if Alice and Bob both use PKI, they also must share the same root
    > certificate for the validation to be successful.

 8. If Bob accepts the request (after being validated), it creates the Alice's user and
    device certificates with the provided user & device public keys.
 9. Bob sends to the Parsec the accept payload along with its signature. This is similar
    to step 5 (but in reverse order).
10. Alice checks the Parsec server periodically (polling) until she obtains the accept payload.
11. Alice verifies Bob's accept payload. This is similar to step 7.
12. Alice creates the final local device containing the user encryption key and device
    signing key. She also remove the file created during step 4 that represents a pending
    enrollment.

## 3 - Protocol

### 3.1 - Submit the request to join an organization

Anonymous API:

```json5
[
    {
        "major_versions": [
            5
        ],
        "cmd": "async_enrollment_submit",
        "req": {
            "fields": [
                {
                    // UUID of the current request, generated by the sender.
                    "name": "enrollment_id",
                    "type": "AsyncEnrollmentID"
                },
                {
                    // Allow to submit a new request to replace a pending one.
                    // A request is identified by its `submitter_der_x509_certificate`.
                    "name": "force",
                    "type": "Boolean"
                },
                {
                    // `AsyncEnrollmentSubmitPayload` serialized in msgpack format.
                    // Must check `submit_payload_signature` before loading it!
                    "name": "submit_payload",
                    "type": "Bytes"
                },
                {
                    "name": "submit_payload_signature",
                    "type": "SubmitPayloadSignature"
                }
            ]
        },
        "reps": [
            {
                // The request was accepted by the server and need to be reviewed by an organization admin.
                "status": "ok",
                "fields": [
                    {
                        "name": "submitted_on",
                        "type": "DateTime"
                    }
                ]
            },
            {
                // An enrollment request already exist for the provided certificate.
                "status": "already_submitted",
                "fields": [
                    {
                        "name": "submitted_on",
                        "type": "DateTime"
                    }
                ]
            },
            {
                "status": "id_already_used"
            },
            {
                // The server check if an user doesn't already exist using the email contained in the certificate.
                "status": "email_already_used"
            },
            {
                // `submit_payload` field doesn't correspond to a valid `AsyncEnrollmentSubmitPayload`
                "status": "invalid_submit_payload"
            },
            {
                // `submit_payload_signature` cannot be verified by the server
                "status": "invalid_submit_payload_signature"
            }
        ],
        "nested_types": [
            {
                "name": "SubmitPayloadSignature",
                "discriminant_field": "type",
                "variants": [
                    {
                        "name": "PKI",
                        "discriminant_value": "PKI",
                        "fields": [
                            {
                                "name": "signature",
                                "type": "Bytes"
                            },
                            {
                                "name": "algorithm",
                                "type": "PkiSignatureAlgorithm"
                            },
                            {
                                // The certificate used by the submitter to sign the request.
                                "name": "submitter_der_x509_certificate",
                                "type": "Bytes"
                            },
                            {
                                // Optional list of intermediate certificates needed to
                                // validate the certificate chain from `submitter_der_x509_certificate`
                                // up to the root certificate.
                                // Also note that both accepter and submitter must share the
                                // same root certificate for the validation to succeed.
                                "name": "intermediate_der_x509_certificates",
                                "type": "List<Bytes>"
                            }
                        ]
                    },
                    {
                        "name": "OpenBao",
                        "discriminant_value": "OPEN_BAO",
                        "fields": [
                            {
                                // Signature returned by OpenBao using API at
                                // `<openbao_server_url>/v1/transit/sign/entity_alias_<submitter_openbao_entity_alias_id>`
                                //
                                // Note this is a string, as OpenBao speaks JSON and its signatures typically looks something like:
                                // `vault:v1:C4jRZx+ymLou26tN8Q2KDy46dA47W7x/MH6nuEZVqdz+H0RvoaFbQUAHceBKhB+Qow2qXAXiRFAFWKGPZU93CQ==`
                                "name": "signature",
                                "type": "String"
                            },
                            {
                                // Key used for signature verification is located at
                                // `<openbao_server_url>/v1/transit/verify/entity_alias_<submitter_openbao_entity_alias_id>`
                                //
                                // Note once the signature verification is done, the submitter's
                                // email can be obtained from OpenBao using API at
                                // `<openbao_server_url>/v1/identity/entity-alias/id/<submitter_openbao_entity_alias_id>`.
                                //
                                // This is important at the submitter email must match with the
                                // email specified in the `AsyncEnrollmentSubmitPayload`!
                                "name": "submitter_openbao_entity_alias_id",
                                "type": "String"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]
```

```json5
{
    "label": "AsyncEnrollmentSubmitPayload",
    "type": "async_enrollment_submit_payload",
    "other_fields": [
        {
            "name": "verify_key",
            "type": "VerifyKey"
        },
        {
            "name": "public_key",
            "type": "PublicKey"
        },
        {
            // Submitter asks for device_label/human_handle, but accepter has final word on this
            "name": "requested_device_label",
            "type": "DeviceLabel"
        },
        {
            // Note the email in the HumanHandle should not be blindly trusted here !
            // Instead the identity validation step should ensure it correspond with
            // what is expected (e.g. when using PKI, it corresponds to the `subjectAltName`
            // field in the submitter's x509 certificate).
            "name": "requested_human_handle",
            "type": "HumanHandle"
        }
    ]
}
```

### 3.2 - List the pending request

Authenticated API:

```json5
[
    {
        "major_versions": [
            5
        ],
        "cmd": "async_enrollment_list",
        "req": {},
        "reps": [
            {
                "status": "ok",
                "fields": [
                    {
                        "name": "enrollments",
                        "type": "List<Enrollment>"
                    }
                ]
            },
            {
                // Only user with ADMIN profile can use this command
                "status": "author_not_allowed"
            }
        ],
        "nested_types": [
            {
                "name": "Enrollment",
                "fields": [
                    {
                        // UUID of the request
                        "name": "enrollment_id",
                        "type": "AsyncEnrollmentID"
                    },
                    {
                        // When the request was made
                        "name": "submitted_on",
                        "type": "DateTime"
                    },
                    {
                        // `AsyncEnrollmentSubmitPayload` serialized in msgpack format,
                        // Must check `submit_payload_signature` before loading it!
                        "name": "submit_payload",
                        "type": "Bytes"
                    },
                    {
                        "name": "submit_payload_signature",
                        "type": "SubmitPayloadSignature"
                    }
                ]
            },
            {
                "name": "SubmitPayloadSignature",
                "discriminant_field": "type",
                "variants": [
                    {
                        "name": "PKI",
                        "discriminant_value": "PKI",
                        "fields": [
                            {
                                "name": "signature",
                                "type": "Bytes"
                            },
                            {
                                "name": "algorithm",
                                "type": "PkiSignatureAlgorithm"
                            },
                            {
                                // The certificate used by the submitter to sign the request.
                                // The server does not perform any validation on the certificate,
                                // those verifications need to be made by the "accepter"
                                "name": "submitter_der_x509_certificate",
                                "type": "Bytes"
                            },
                            {
                                // Optional list of intermediate certificates needed to
                                // validate the certificate chain from `submitter_der_x509_certificate`
                                // up to the root certificate.
                                // Also note that both accepter and submitter must share the
                                // same root certificate for the validation to succeed.
                                "name": "intermediate_der_x509_certificates",
                                "type": "List<Bytes>"
                            }
                        ]
                    },
                    {
                        "name": "OpenBao",
                        "discriminant_value": "OPEN_BAO",
                        "fields": [
                            {
                                // Signature returned by OpenBao using API at
                                // `<openbao_server_url>/v1/transit/sign/entity_alias_<submitter_openbao_entity_alias_id>`
                                //
                                // Note this is a string, as OpenBao speaks JSON and its signatures typically looks something like:
                                // `vault:v1:C4jRZx+ymLou26tN8Q2KDy46dA47W7x/MH6nuEZVqdz+H0RvoaFbQUAHceBKhB+Qow2qXAXiRFAFWKGPZU93CQ==`
                                "name": "signature",
                                "type": "String"
                            },
                            {
                                // Key used for signature verification is located at
                                // `<openbao_server_url>/v1/transit/verify/entity_alias_<submitter_openbao_entity_alias_id>`
                                //
                                // Note once the signature verification is done, the submitter's
                                // email can be obtained from OpenBao using API at
                                // `<openbao_server_url>/v1/identity/entity-alias/id/<submitter_openbao_entity_alias_id>`.
                                //
                                // This is important at the submitter email must match with the
                                // email specified in the `AsyncEnrollmentSubmitPayload`!
                                "name": "submitter_openbao_entity_alias_id",
                                "type": "String"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]
```

### 3.3 - Reject the enrollment request

Authenticated API:

```json5
[
    {
        "major_versions": [
            5
        ],
        "cmd": "async_enrollment_reject",
        "req": {
            "fields": [
                {
                    // The enrollment ID to be rejected
                    "name": "enrollment_id",
                    "type": "AsyncEnrollmentID"
                }
            ]
        },
        "reps": [
            {
                "status": "ok"
            },
            {
                // Only user with ADMIN profile can use this command
                "status": "author_not_allowed"
            },
            {
                // The server did not found a request for the provided ID
                "status": "enrollment_not_found"
            },
            {
                // The request is no longer in pending state (either accepted, cancelled or rejected)
                "status": "enrollment_no_longer_available"
            }
        ]
    }
]
```

### 3.4 - Accept the enrollment request

Authenticated API:

```json5
[
    {
        "major_versions": [
            5
        ],
        "cmd": "async_enrollment_accept",
        "req": {
            "fields": [
                {
                    // The enrollment ID to be accepted
                    "name": "enrollment_id",
                    "type": "AsyncEnrollmentID"
                },
                {
                    // User certificate for the submitter (created by the accepter)
                    "name": "submitter_user_certificate",
                    "type": "Bytes"
                },
                {
                    // Device certificate for the submitter (created by the accepter)
                    "name": "submitter_device_certificate",
                    "type": "Bytes"
                },
                {
                    // Same certificate than `submitter_user_certificate` but expunged of `human_handle`
                    "name": "submitter_redacted_user_certificate",
                    "type": "Bytes"
                },
                {
                    // Same certificate than `submitter_device_certificate` but expunged of `device_label`
                    "name": "submitter_redacted_device_certificate",
                    "type": "Bytes"
                },
                {
                    // `AsyncEnrollmentAcceptPayload` in msgpack format.
                    // Must check `accept_payload_signature` before loading it!
                    "name": "accept_payload",
                    "type": "Bytes"
                },
                {
                    "name": "accept_payload_signature",
                    "type": "AcceptPayloadSignature"
                }
            ]
        },
        "reps": [
            {
                "status": "ok"
            },
            {
                // The user does not have the permission required to perform this action
                "status": "author_not_allowed"
            },
            {
                // One of the provided certificate is not valid
                "status": "invalid_certificate"
            },
            {
                // `accept_payload` field doesn't correspond to a valid `AsyncEnrollmentAcceptPayload`
                "status": "invalid_accept_payload"
            },
            {
                // `accept_payload_signature` cannot be verified by the server
                "status": "invalid_accept_payload_signature"
            },
            {
                // The server did not found a request for the provided ID
                "status": "enrollment_not_found"
            },
            {
                // The request is no longer in pending state (either accepted, cancelled or rejected)
                "status": "enrollment_no_longer_available"
            },
            {
                // The organization has reached the maximum number of active users
                "status": "active_users_limit_reached"
            },
            {
                // The user already exist in the organization (i.e. user ID already in use)
                "status": "user_already_exists"
            },
            {
                // The user's human handle is already taken (i.e. email already in use)
                "status": "human_handle_already_taken"
            },
            {
                // Returned if the timestamp in the certificate is too far away compared
                // to server clock.
                "status": "timestamp_out_of_ballpark",
                "fields": [
                    {
                        "name": "ballpark_client_early_offset",
                        "type": "Float"
                    },
                    {
                        "name": "ballpark_client_late_offset",
                        "type": "Float"
                    },
                    {
                        "name": "server_timestamp",
                        "type": "DateTime"
                    },
                    {
                        "name": "client_timestamp",
                        "type": "DateTime"
                    }
                ]
            },
            {
                // Returned if another certificate in the server has a timestamp
                // posterior or equal to our current one.
                "status": "require_greater_timestamp",
                "fields": [
                    {
                        "name": "strictly_greater_than",
                        "type": "DateTime"
                    }
                ]
            }
        ],
        "nested_types": [
            {
                "name": "AcceptPayloadSignature",
                "discriminant_field": "type",
                "variants": [
                    {
                        "name": "PKI",
                        "discriminant_value": "PKI",
                        "fields": [
                            {
                                "name": "signature",
                                "type": "Bytes"
                            },
                            {
                                "name": "algorithm",
                                "type": "PkiSignatureAlgorithm"
                            },
                            {
                                // Certificate used by the accepter to sign the payload
                                "name": "accepter_der_x509_certificate",
                                "type": "Bytes"
                            },
                            {
                                // Optional list of intermediate certificates needed to
                                // validate the certificate chain from `accepter_der_x509_certificate`
                                // up to the root certificate.
                                // Also note that both accepter and submitter must share the
                                // same root certificate for the validation to succeed.
                                "name": "intermediate_der_x509_certificates",
                                "type": "List<Bytes>"
                            }
                        ]
                    },
                    {
                        "name": "OpenBao",
                        "discriminant_value": "OPEN_BAO",
                        "fields": [
                            {
                                // Signature returned by OpenBao using API at
                                // `<openbao_server_url>/v1/transit/sign/entity_alias_<accepter_openbao_entity_alias_id>`
                                //
                                // Note this is a string, as OpenBao speaks JSON and its signatures typically looks something like:
                                // `vault:v1:C4jRZx+ymLou26tN8Q2KDy46dA47W7x/MH6nuEZVqdz+H0RvoaFbQUAHceBKhB+Qow2qXAXiRFAFWKGPZU93CQ==`
                                "name": "signature",
                                "type": "String"
                            },
                            {
                                // Key used for signature verification is located at
                                // `<openbao_server_url>/v1/transit/verify/entity_alias_<accepter_openbao_entity_alias_id>`
                                //
                                // Note once the signature verification is done, the submitter's
                                // email can be obtained from OpenBao using API at
                                // `<openbao_server_url>/v1/identity/entity-alias/id/<submitter_openbao_entity_alias_id>`.
                                //
                                // This is purely informative though, since (unlike for
                                // `AsyncEnrollmentSubmitPayload`) the signer's email is
                                // not specified (and hence cannot be matched against)
                                // in the `AsyncEnrollmentAcceptPayload`.
                                "name": "accepter_openbao_entity_alias_id",
                                "type": "String"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]
```

```json5
{
    "label": "AsyncEnrollmentAcceptPayload",
    "type": "async_enrollment_accept_payload",
    "other_fields": [
        {
            "name": "user_id",
            "type": "UserID"
        },
        {
            "name": "device_id",
            "type": "DeviceID"
        },
        {
            "name": "device_label",
            "type": "DeviceLabel"
        },
        {
            "name": "human_handle",
            "type": "HumanHandle"
        },
        {
            "name": "profile",
            "type": "UserProfile"
        },
        {
            "name": "root_verify_key",
            "type": "VerifyKey"
        }
    ]
}
```

### 3.5 - Check the status of a request

Anonymous API:

```json5
[
    {
        "major_versions": [
            5
        ],
        "cmd": "async_enrollment_info",
        "req": {
            "fields": [
                {
                    // The enrollment ID for which information is requested
                    "name": "enrollment_id",
                    "type": "AsyncEnrollmentID"
                }
            ]
        },
        "reps": [
            {
                "status": "ok",
                "unit": "InfoStatus"
            },
            {
                // The server did not found a request for the provided ID
                "status": "enrollment_not_found"
            }
        ],
        "nested_types": [
            {
                "name": "InfoStatus",
                "discriminant_field": "enrollment_status",
                "variants": [
                    {
                        "name": "Submitted",
                        "discriminant_value": "SUBMITTED",
                        "fields": [
                            {
                                "name": "submitted_on",
                                "type": "DateTime"
                            }
                        ]
                    },
                    {
                        "name": "Rejected",
                        "discriminant_value": "REJECTED",
                        "fields": [
                            {
                                "name": "submitted_on",
                                "type": "DateTime"
                            },
                            {
                                "name": "rejected_on",
                                "type": "DateTime"
                            }
                        ]
                    },
                    {
                        "name": "Cancelled",
                        "discriminant_value": "CANCELLED",
                        "fields": [
                            {
                                "name": "submitted_on",
                                "type": "DateTime"
                            },
                            {
                                "name": "cancelled_on",
                                "type": "DateTime"
                            }
                        ]
                    },
                    {
                        "name": "Accepted",
                        "discriminant_value": "ACCEPTED",
                        "fields": [
                            {
                                "name": "submitted_on",
                                "type": "DateTime"
                            },
                            {
                                "name": "accepted_on",
                                "type": "DateTime"
                            },
                            {
                                // `AsyncEnrollmentAcceptPayload` in msgpack format.
                                // Must check `accept_payload_signature` before loading it!
                                "name": "accept_payload",
                                "type": "Bytes"
                            },
                            {
                                "name": "accept_payload_signature",
                                "type": "AcceptPayloadSignature"
                            }
                        ]
                    }
                ]
            },
            {
                "name": "AcceptPayloadSignature",
                "discriminant_field": "type",
                "variants": [
                    {
                        "name": "PKI",
                        "discriminant_value": "PKI",
                        "fields": [
                            {
                                "name": "signature",
                                "type": "Bytes"
                            },
                            {
                                "name": "algorithm",
                                "type": "PkiSignatureAlgorithm"
                            },
                            {
                                // Certificate used by the accepter to sign the payload
                                "name": "accepter_der_x509_certificate",
                                "type": "Bytes"
                            },
                            {
                                // Optional list of intermediate certificates needed to
                                // validate the certificate chain from `submitter_der_x509_certificate`
                                // up to the root certificate.
                                // Also note that both accepter and submitter must share the
                                // same root certificate for the validation to succeed.
                                "name": "intermediate_der_x509_certificates",
                                "type": "List<Bytes>"
                            }
                        ]
                    },
                    {
                        "name": "OpenBao",
                        "discriminant_value": "OPEN_BAO",
                        "fields": [
                            {
                                // Signature returned by OpenBao using API at
                                // `<openbao_server_url>/v1/transit/sign/entity_alias_<accepter_openbao_entity_alias_id>`
                                //
                                // Note this is a string, as OpenBao speaks JSON and its signatures typically looks something like:
                                // `vault:v1:C4jRZx+ymLou26tN8Q2KDy46dA47W7x/MH6nuEZVqdz+H0RvoaFbQUAHceBKhB+Qow2qXAXiRFAFWKGPZU93CQ==`
                                "name": "signature",
                                "type": "String"
                            },
                            {
                                // Key used for signature verification is located at
                                // `<openbao_server_url>/v1/transit/verify/entity_alias_<accepter_openbao_entity_alias_id>`
                                //
                                // Note once the signature verification is done, the submitter's
                                // email can be obtained from OpenBao using API at
                                // `<openbao_server_url>/v1/identity/entity-alias/id/<submitter_openbao_entity_alias_id>`.
                                //
                                // This is purely informative though, since (unlike for
                                // `AsyncEnrollmentSubmitPayload`) the signer's email is
                                // not specified (and hence cannot be matched against)
                                // in the `AsyncEnrollmentAcceptPayload`.
                                "name": "accepter_openbao_entity_alias_id",
                                "type": "String"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]
```

### 3.6 - New event for async enrollment changes

Update the `events_listen` authenticated command:

```json5
[
    {
        "major_versions": [
            5
        ],
        "cmd": "events_listen",
        ...
        "nested_types": [
            {
                "name": "APIEvent",
                "discriminant_field": "event",
                "variants": [
                    ...
                    {
                        // Event only fired for organization admins
                        "name": "AsyncEnrollment",
                        "discriminant_value": "ASYNC_ENROLLMENT"
                    },
                    ...
                ]
            }
        ]
    }
]
```

Notes:

- This event is fired whenever a new async enrollment is created (i.e. in `async_enrollment_submit`)
  or if an existing async enrollment is accepted/rejected.
- This event is only fired for users with ADMIN profile, since only them can interract
  with the async enrollments.

### 4 - Data: Local pending enrollment

```json5
{
    "label": "AsyncEnrollmentLocalPending",
    "type": "async_enrollment_local_pending",
    "other_fields": [
        {
            // Url to the server in the format `https://parsec.example.com:443`.
            // Note we don't use the `parsec3://` scheme here to avoid compatibility
            // issue if we later decide to change the scheme.
            "name": "server_url",
            "type": "ParsecAddr"
        },
        {
            "name": "organization_id",
            "type": "OrganizationID"
        },
        {
            "name": "submitted_on",
            "type": "DateTime"
        },
        {
            "name": "enrollment_id",
            "type": "AsyncEnrollmentID"
        },
        {
            // Submitter asks for device_label/human_handle, but accepter has final word on this
            "name": "requested_device_label",
            "type": "DeviceLabel"
        },
        {
            "name": "requested_human_handle",
            "type": "HumanHandle"
        },
        {
            // The identity system refers to the 3rd party component that is responsible for:
            // 1 - Sign the submit payload
            // 2 - Protect the soon-to-become user&device private keys
            // 3 - Validate the accept payload
            "name": "identity_system",
            "type": "AsyncEnrollmentLocalPendingIdentitySystem"
        },
        {
            // To-be-created device's `VerifyKey` encrypted with the ciphertext
            // key (i.e. a `SecretKey`) from the identity system.
            "name": "ciphertext_signing_key",
            "type": "Bytes"
        },
        {
            // To-be-created user's `PrivateKey` encrypted with the ciphertext
            // key (i.e. a `SecretKey`) from the identity system.
            "name": "ciphertext_private_key",
            "type": "Bytes"
        }
    ],

    "nested_types": [
        {
            "name": "AsyncEnrollmentLocalPendingIdentitySystem",
            "discriminant_field": "type",
            "variants": [
                {
                    "name": "PKI",
                    "discriminant_value": "PKI",
                    "fields": [
                        {
                            // The ciphertext key (i.e. a `SecretKey`) encrypted
                            // by an asymmetric key from the smartcard.
                            "name": "encrypted_key",
                            "type": "Bytes"
                        },
                        {
                            // Reference to the asymmetric key from the smartcard used
                            // to encrypt the ciphertext key.
                            "name": "certificate_ref",
                            "type": "X509CertificateReference"
                        },
                        {
                            // Algorithm used to encrypt `encrypted_key` field
                            "name": "algorithm_for_encrypted_key",
                            "type": "PKIEncryptionAlgorithm"
                        }
                    ]
                },
                {
                    "name": "OpenBao",
                    "discriminant_value": "OPEN_BAO",
                    "fields": [
                        // A word about the OpenBao info stored here.
                        //
                        // To fetch/upload an OpenBao secret we need multiple things:
                        // 1. The address of the OpenBao server.
                        // 2. The authentication to use (e.g. "OIDC SSO with Github as identity provider").
                        // 3. The mount path of the authentication method (e.g. `auth/oidc/github`).
                        // 4. The mount path of the secret store (e.g. `secrets/parsec-keys`).
                        // 5. The path of the secret within the secret store.
                        //
                        // However all those info are not stored in (and hence obtained from) this
                        // device keys file since it would make them complex to change in the future.
                        // So instead the OpenBao server configuration (i.e. server address, list
                        // of supported authentication methods, mount paths) is to be obtained
                        // from the Parsec server each time we need to load this device keys file.
                        {
                            // Arbitrary field only used by the GUI.
                            //
                            // In practice, it is expected to contain a `OpenBaoAuthType`
                            // corresponding to the authentication method that have been used
                            // to authenticate to OpenBao during the creation of this device keys file.
                            //
                            // The idea here is to allow the GUI to use this again during subsequent
                            // access of this device keys file in order to pre-select the
                            // authentication method that should be used.
                            //
                            // Note we use a string instead of directly a `OpenBaoAuthType` for backward
                            // compatibility (given, even if the auth ID is unknown, we could still
                            // be able to decrypt this device file if the user can authenticate to
                            // OpenBao using a different SSO auth).
                            "name": "openbao_preferred_auth_id",
                            "type": "String"
                        },
                        {
                            // Entity ID basically correspond to an account ID in OpenBao.
                            // So the GUI should authenticate as this entity in OpenBao in order
                            // to be able to fetch the secret containing the ciphertext key.
                            "name": "openbao_entity_id",
                            "type": "String"
                        },
                        {
                            // The ciphertext key is stored in OpenBao as a secret that is has
                            // for path `<entity_id>/<ciphertext key UUID>`.
                            //
                            // Note we don't just use the ciphertext key UUID as path since OpenBao
                            // is expected to be configured with path-based access policy (i.e.
                            // a given entity is only allowed to access the secrets starting with
                            // its entity ID).
                            "name": "openbao_ciphertext_key_path",
                            "type": "String"
                        }
                    ]
                }
            ]
        }
    ]
}
```

## 5 - Identity validation

### 5.1 - PKI based

In PKI mode, the submitter signs his request payload using his personal PKI's signing key, then
provides it along with his personal x509 certificate (and any intermediary x509 certificates needed).

This way submit payload validation is done by:

1 - Validating the x509 certificate chain
2 - Ensuring the x509 root certificate in the chain is expected (see below).
3 - Validating the submit payload signature according to the verify key in the submitter's x509 certificate.
4 - Checking the email in the `requested_human_handle` field of the submit payload correspond
    to the `subjectAltName` field in the submitter's x509 certificate.

Such validation is done at two levels:

- In the accepter client: here the x509 root certificate is the same as the one for the
  accepter's x509 certificate.
- Server : here the allowed x509 root certificate are configured at startup.

> [!NOTE]
> The server validation is not strictly needed from a security standpoint, but it
> prevents ending up with bad request in the list of pending enrollments that then
> have to be manually rejected.

Finally the accepter also signs his accept payload that has to be then validated
by the submitter.
This step is similar to the submit payload validation, except for step 4 that is
omitted.

### 5.2 - OpenBao based

#### 5.2.1 - Overview

In OpenBao, the [transit engine](https://openbao.org/api-docs/secret/transit/) is used
to sign and verify the submit & accept payloads on the behalf of an authenticated user.

Payload exchange from Alice to Bob works as follow:
1 - Alice authenticates using OIDC, this provides a token that will be used to
    authenticate in all OpenBao operations.
    The authentication (entity alias in OpenBao jargon) as an ID (entity alias ID).
2 - Alice creates in OpenBao a signing key for the entity alias ID if it doesn't
    already exist.
3 - Alice asks OpenBao to sign the payload using the signing key.
4 - Alice transmits the payload, its signature and the entity alias ID to Bob.
5 - Bob authenticate using OIDC.
6 - Bob asks OpenBao to verify that the signature correspond to the payload signed
    with the entity alias ID provided by Alice.
7 - Bob ask OpenBao to get the email associated with the entity alias ID.

> [!NOTE]
>
> - Only Alice is allowed to create and use the signing key for her entity alias ID
> - Any authenticated user is able to verify a payload signed with any key.
> - Any authenticated user is able to obtain the email from a entity alias ID. This is
>   required to link the identity with the signed payload.
>   Note we don't consider it to be an oracle since the entity alias ID is a UUID,
>   so realistically only known entity alias ID can be queried.

#### 5.2.2 - In-depth OpenBao queries

A more in-depth representation of this dance:

```python
# Step 1 omitted
# Alice entity alias ID is `d42286c0-a41d-bf0f-7dab-c9c27a0f0a58`

# Step 2: Create key
POST https://openbao-dev.parsec.cloud/v1/transit/keys/user-d42286c0-a41d-bf0f-7dab-c9c27a0f0a58
Headers: {"X-Vault-Token": "s.XXX"}
<<< status: 200 (also 200 if key already exists)
<<< {'request_id': '1cfb7461-5b77-333f-b952-21f34149267f', 'lease_id': '', 'renewable': False, 'lease_duration': 0, 'data': {'allow_plaintext_backup': False, 'auto_rotate_period': 0, 'deletion_allowed': False, 'derived': False, 'exportable': False, 'imported_key': False, 'keys': {'1': {'certificate_chain': '', 'creation_time': '2025-12-01T15:50:33.606080602Z', 'name': 'ed25519', 'public_key': 'ig9jt4uLZj4AxYSqdS3XkyymPamEijV4JaNHAfa1yUY='}}, 'latest_version': 1, 'min_available_version': 0, 'min_decryption_version': 1, 'min_encryption_version': 0, 'name': 'user-d42286c0-a41d-bf0f-7dab-c9c27a0f0a58', 'soft_deleted': False, 'supports_decryption': False, 'supports_derivation': True, 'supports_encryption': False, 'supports_signing': True, 'type': 'ed25519'}, 'wrap_info': None, 'warnings': None, 'auth': None}

# Step 3: Sign payload
POST https://openbao-dev.parsec.cloud/v1/transit/sign/user-d42286c0-a41d-bf0f-7dab-c9c27a0f0a58
Headers: {"X-Vault-Token": "s.XXX"}
<<< status: 200
<<< {'request_id': '1288a880-525e-5e8d-a630-33e2c63847c6', 'lease_id': '', 'renewable': False, 'lease_duration': 0, 'data': {'key_version': 1, 'signature': 'vault:v1:C4jRZx+ymLou26tN8Q2KDy46dA47W7x/MH6nuEZVqdz+H0RvoaFbQUAHceBKhB+Qow2qXAXiRFAFWKGPZU93CQ=='}, 'wrap_info': None, 'warnings': None, 'auth': None}

# Step 4&5 omitted

# Step 6: Bob verify payload
POST https://openbao-dev.parsec.cloud/v1/transit/verify/user-d42286c0-a41d-bf0f-7dab-c9c27a0f0a58
Headers: {"X-Vault-Token": "s.YYY"}
<<< status: 200
<<< {'request_id': 'c9a0db94-53a3-682d-e2a9-52d351541a6b', 'lease_id': '', 'renewable': False, 'lease_duration': 0, 'data': {'valid': True}, 'wrap_info': None, 'warnings': None, 'auth': None}

# Step 7: Bob get Alice's email from its entity alias ID
GET https://openbao-dev.parsec.cloud/v1/identity/entity-alias/id/d42286c0-a41d-bf0f-7dab-c9c27a0f0a58
Headers: {"X-Vault-Token": "s.YYY"}
<<< status: 200
<<< {'request_id': '361568ce-b924-298f-dd05-2e58e0046178', 'lease_id': '', 'renewable': False, 'lease_duration': 0, 'data': {'canonical_id': '217b7a03-b4d0-aff6-eaa8-4e1aa0573193', 'creation_time': '2025-12-01T15:09:53Z', 'custom_metadata': None, 'id': 'd42286c0-a41d-bf0f-7dab-c9c27a0f0a58', 'last_update_time': '2025-12-01T15:09:53Z', 'local': False, 'merged_from_canonical_ids': None, 'metadata': {'role': 'default'}, 'mount_accessor': 'auth_oidc_e99f8297', 'mount_path': 'auth/oidc/', 'mount_type': 'oidc', 'name': 'test@fia1.fr', 'namespace_id': 'root'}, 'wrap_info': None, 'warnings': None, 'auth': None}
```

#### 5.2.3 - In-depth OpenBao configuration

For This mechanism to work, the OpenBao server has to be configured in three ways:

- Transit engine has to be enabled.
- OIDC-based authentication has to use the email provided by the authority provider
  as the entity alias name.
- An ACL policy has to be configured for OIDC-authenticated users so that they
  can use the transit engine.

Enable transit engine:

```bash
bao secrets enable -address $OPENBAO_SERVER_URL transit
```

Configure to use email as entity alias name (considering the authentication method
is mounted at `my_oidc`, and the user request the `default` ACL policy).

```bash
bao write -address $OPENBAO_SERVER_URL$ auth/my_oidc/role/default user_claim="email"
```

ACL policy (considering the authentication method has for accessor `auth_oidc_e99f8297`):

```hcl
#
# Parsec entity-to-entity authenticated message passing
# (used for asynchronous enrollment to sign `AsyncEnrollmentSubmitPayload` & `AsyncEnrollmentAcceptPayload`)
#

# User (authenticated using OIDC) creates its signing key
path "transit/keys/user-{{identity.entity.aliases.auth_oidc_e99f8297.id}}" {
    capabilities = ["update"]
}
# User (authenticated using OIDC) sign a message
path "transit/sign/user-{{identity.entity.aliases.auth_oidc_e99f8297.id}}" {
    capabilities = ["update"]
}

# Other user gets the email from the entity's alias that signed a message
path "identity/entity-alias/id/*" {
    capabilities = ["read"]
}

# Other user verifies a message's signature
path "transit/verify/user-*" {
    capabilities = ["update"]
}
```
